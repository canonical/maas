{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/maasserver/static/js/angular/3rdparty/ng-tags-input.js","webpack:///./src/maasserver/static/js/angular/3rdparty/vs-repeat.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","KEYS","SUPPORTED_INPUT_TYPES","tagsInput","angular","directive","$timeout","$document","$window","tagsInputConfig","tiUtil","validateType","type","indexOf","restrict","require","scope","tags","onTagAdding","onTagAdded","onInvalidTag","onTagRemoving","onTagRemoved","replace","transclude","templateUrl","controller","$scope","$attrs","$element","events","simplePubSub","load","template","String","placeholder","tabindex","Number","removeTagSymbol","fromCharCode","replaceSpacesWithDashes","Boolean","minLength","maxLength","addOnEnter","addOnSpace","addOnComma","addOnBlur","addOnPaste","pasteSplitPattern","RegExp","allowedTagsPattern","enableEditingLastTag","minTags","maxTags","displayProperty","keyProperty","allowLeftoverText","addFromAutocompleteOnly","spellcheck","tagList","options","getTagText","setTagText","tagIsValid","self","tag","safeToString","text","tagText","length","test","findInObjectArray","items","$tag","addText","add","push","trigger","remove","index","splice","clearSelection","select","selected","selectPrior","selectNext","removeSelected","handleUndefinedResult","this","registerAutocomplete","find","addTag","focusInput","getTags","getCurrentTagText","newTag","getOptions","on","handler","registerTagItem","removeTag","disabled","link","element","attrs","ngModelCtrl","setElementValidity","hotkeys","input","validationOptions","$setValidity","hasFocus","$isEmpty","invalid","setText","track","$watch","makeObjectArray","$observe","eventHandlers","change","keydown","$event","focus","blur","activeElement","prop","lostFocusToBrowserWindow","lostFocusToChildElement","contains","paste","getTextData","clipboardData","originalEvent","getData","host","click","$setViewValue","e","triggerHandler","event","shouldAdd","shouldRemove","shouldSelect","shouldEditLastTag","key","keyCode","addKeys","shiftKey","altKey","ctrlKey","metaKey","preventDefault","split","forEach","data","tagsInputCtrl","$$template","$$removeTagSymbol","$getDisplayText","$removeTag","$index","$sce","$q","source","debounceDelay","highlightMatchedText","maxResultsToShow","loadOnDownArrow","loadOnEmpty","loadOnFocus","selectFirstMatch","suggestionList","loadFn","getDifference","lastPromise","getTagId","array1","array2","filter","item","a","b","defaultComparer","reset","visible","query","show","debounce","promise","when","$query","then","slice","registerAutocompleteMatch","getQuery","shouldLoadSuggestions","addSuggestionByIndex","addSuggestion","added","copy","handled","stopImmediatePropagation","root","eq","parent","elementTop","elementHeight","parentHeight","parentScrollTop","scrollToElement","autoCompleteCtrl","autoComplete","$parent","$highlight","safeHighlight","trustAsHtml","ctrl","transcludeFn","clone","append","span","resize","threshold","getTextAutosizeThreshold","css","originalValue","width","isString","$parsers","unshift","$formatters","$modelValue","tiBindAttrs","$set","provider","globalDefaults","interpolationStatus","autosizeThreshold","setDefaults","defaults","setActiveInterpolation","setTextAutosizeThreshold","$get","$interpolate","converters","parseInt","toLowerCase","defaultValidator","localDefault","validator","converter","getDefault","updateValue","globalValue","isDefined","newValue","factory","fn","delay","timeoutId","args","arguments","cancel","apply","array","isObject","obj","comparer","some","str","encodeHTML","expression","escapeRegexChars","match","isUndefined","toString","trim","valueIfUndefined","result","names","every","run","$templateCache","put","_extends","assign","target","_slicedToArray","arr","Array","isArray","Symbol","iterator","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","_sliceIterator","TypeError","window","closestElement","closest","matchingFunction","reduce","res","_res","document","documentElement","selector","_el","el","parentNode","getWindowScroll","_ref","_document$documentEle","_ref2","_document$documentEle2","scrollTop","pageYOffset","scrollLeft","pageXOffset","body","getClientSize","sizeProp","innerWidth","innerHeight","attrDeprecated","attrname","message","console","warn","concat","printDeprecationWarning","defaultOptions","latch","container","scrollParent","size","offsetBefore","offsetAfter","scrolledToBeginning","noop","scrolledToEnd","scrolledToBeginningOffset","scrolledToEndOffset","scrollMargin","horizontal","autoresize","hunked","hunkSize","vsRepeatModule","$compile","$parse","compile","compileElement","compileAttrs","compileRepeatContainer","querySelector","vsRepeatContainer","repeatContainerChildren","children","ngRepeatChild","childCloneHtml","outerHTML","collectionName","_analyzeNgRepeatUsage2","opt","attr","Error","analyzeNgRepeatUsage","originalNgRepeatAttr","ngRepeatExpression","isNgRepeatStart","_expressionMatches","exec","lhs","rhs","rhsSuffix","repeaterElement","empty","pre","_$scope$$eval","_parseSize","getSize","parsed","writable","vsRepeat","$eval","originalLength","repeatContainer","childClone","childTagName","tagName","originalCollection","$beforeContent","$afterContent","autosizingRequired","$scrollParent","clientSize","offsetSize","scrollSize","scrollPos","totalSize","sizesCumulative","debug","$debugParent","$debug","$on","_prevStartIndex","_prevEndIndex","_minStartIndex","_maxEndIndex","_prevClientSize","measuredSize","refresh","_mapSize","getFromMeasured","reinitialize","hardSize","sizes","map","_hardSize","sum","arr2","from","_toConsumableArray","$$postDigest","offsetHeight","offsetWidth","gotSomething","insideStartEndSequence","attributes","$root","$$phase","$digest","dereg","getLayoutProps","layoutProp","acc","scrollHandler","pos","updateInnerCollection","_ensureScrollIntegrity","onWindowResize","$emit","startIndex","endIndex","reinitOnClientHeightChange","ch","binaryFind","Math","floor","scrollProp","$scrollPosition","$clientSize","vsElement","scrollElement","isHorizontal","scrollOffset","getBoundingClientRect","__startIndex","__endIndex","requestAnimationFrame","expectedSize","compStyle","getComputedStyle","paddings","containerSize","relativeScroll","max","min","digestRequired","abs","triggerIndex","o1","o2","total","vsRepeatOptions","$watchCollection","newOpts","mergedOptions","JSON","stringify","coll","addClass","off","setTimeout","head"],"mappings":"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","file":"vendor-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * ngTagsInput v2.3.0\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2015 Michael Benford\n * License: MIT\n *\n * Generated at 2015-03-24 00:49:44 -0300\n */\n(function() {\n'use strict';\n\nvar KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    left: 37,\n    right: 39,\n    delete: 46,\n    comma: 188\n};\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];\n\nvar tagsInput = angular.module('ngTagsInput', []);\n\n/**\n * @ngdoc directive\n * @name tagsInput\n * @module ngTagsInput\n *\n * @description\n * Renders an input box with tag editing support.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n * @param {string=} [keyProperty=text] Property to be used as a unique identifier for the tag.\n * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.\n * @param {number=} tabindex Tab order of the control.\n * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n * @param {number=} [minLength=3] Minimum length for a new tag.\n * @param {number=} [maxLength=MAX_SAFE_INTEGER] Maximum length allowed for a new tag.\n * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.\n * @param {number=} [maxTags=MAX_SAFE_INTEGER] Sets maxTags validation error key if the number of tags added is greater than maxTags.\n * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n *                                             the input element when the directive loses focus.\n * @param {string=} [removeTagSymbol=Ã—] Symbol character for the remove tag button.\n * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.\n * @param {boolean=} [addOnPaste=false] Flag indicating that the text pasted into the input field will be split into tags.\n * @param {string=} [pasteSplitPattern=,] Regular expression used to split the pasted text into tags.\n * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.\n * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n *                                                the new tag input box instead of being removed when the backspace key\n *                                                is pressed and the input box is empty.\n * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n *                                                   allowLeftoverText values are ignored.\n * @param {boolean=} [spellcheck=true] Flag indicating whether the browser's spellcheck is enabled for the input field or not.\n * @param {expression} onTagAdding Expression to evaluate that will be invoked before adding a new tag. The new tag is available as $tag. This method must return either true or false. If false, the tag will not be added.\n * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n * @param {expression} onInvalidTag Expression to evaluate when a tag is invalid. The invalid tag is available as $tag.\n * @param {expression} onTagRemoving Expression to evaluate that will be invoked before removing a tag. The tag is available as $tag. This method must return either true or false. If false, the tag will not be removed.\n * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n */\ntagsInput.directive('tagsInput', [\"$timeout\",\"$document\",\"$window\",\"tagsInputConfig\",\"tiUtil\", function($timeout, $document, $window, tagsInputConfig, tiUtil) {\n    function TagList(options, events, onTagAdding, onTagRemoving) {\n        var self = {}, getTagText, setTagText, tagIsValid;\n\n        getTagText = function(tag) {\n            return tiUtil.safeToString(tag[options.displayProperty]);\n        };\n\n        setTagText = function(tag, text) {\n            tag[options.displayProperty] = text;\n        };\n\n        tagIsValid = function(tag) {\n            var tagText = getTagText(tag);\n\n            return tagText &&\n                   tagText.length >= options.minLength &&\n                   tagText.length <= options.maxLength &&\n                   options.allowedTagsPattern.test(tagText) &&\n                   !tiUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&\n                   onTagAdding({ $tag: tag });\n        };\n\n        self.items = [];\n\n        self.addText = function(text) {\n            var tag = {};\n            setTagText(tag, text);\n            return self.add(tag);\n        };\n\n        self.add = function(tag) {\n            var tagText = getTagText(tag);\n\n            if (options.replaceSpacesWithDashes) {\n                tagText = tiUtil.replaceSpacesWithDashes(tagText);\n            }\n\n            setTagText(tag, tagText);\n\n            if (tagIsValid(tag)) {\n                self.items.push(tag);\n                events.trigger('tag-added', { $tag: tag });\n            }\n            else if (tagText) {\n                events.trigger('invalid-tag', { $tag: tag });\n            }\n\n            return tag;\n        };\n\n        self.remove = function(index) {\n            var tag = self.items[index];\n\n            if (onTagRemoving({ $tag: tag }))  {\n                self.items.splice(index, 1);\n                self.clearSelection();\n                events.trigger('tag-removed', { $tag: tag });\n                return tag;\n            }\n        };\n\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n\n            self.index = index;\n            self.selected = self.items[index];\n        };\n\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n\n        self.removeSelected = function() {\n            return self.remove(self.index);\n        };\n\n        self.clearSelection = function() {\n            self.selected = null;\n            self.index = -1;\n        };\n\n        self.clearSelection();\n\n        return self;\n    }\n\n    function validateType(type) {\n        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;\n    }\n\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        scope: {\n            tags: '=ngModel',\n            onTagAdding: '&',\n            onTagAdded: '&',\n            onInvalidTag: '&',\n            onTagRemoving: '&',\n            onTagRemoved: '&'\n        },\n        replace: false,\n        transclude: true,\n        templateUrl: 'ngTagsInput/tags-input.html',\n        controller: [\"$scope\",\"$attrs\",\"$element\", function($scope, $attrs, $element) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('tagsInput', $scope, $attrs, {\n                template: [String, 'ngTagsInput/tag-item.html'],\n                type: [String, 'text', validateType],\n                placeholder: [String, 'Add a tag'],\n                tabindex: [Number, null],\n                removeTagSymbol: [String, String.fromCharCode(215)],\n                replaceSpacesWithDashes: [Boolean, true],\n                minLength: [Number, 3],\n                maxLength: [Number, MAX_SAFE_INTEGER],\n                addOnEnter: [Boolean, true],\n                addOnSpace: [Boolean, false],\n                addOnComma: [Boolean, true],\n                addOnBlur: [Boolean, true],\n                addOnPaste: [Boolean, false],\n                pasteSplitPattern: [RegExp, /,/],\n                allowedTagsPattern: [RegExp, /.+/],\n                enableEditingLastTag: [Boolean, false],\n                minTags: [Number, 0],\n                maxTags: [Number, MAX_SAFE_INTEGER],\n                displayProperty: [String, 'text'],\n                keyProperty: [String, ''],\n                allowLeftoverText: [Boolean, false],\n                addFromAutocompleteOnly: [Boolean, false],\n                spellcheck: [Boolean, true]\n            });\n\n            $scope.tagList = new TagList($scope.options, $scope.events,\n                tiUtil.handleUndefinedResult($scope.onTagAdding, true),\n                tiUtil.handleUndefinedResult($scope.onTagRemoving, true));\n\n            this.registerAutocomplete = function() {\n                var input = $element.find('input');\n\n                return {\n                    addTag: function(tag) {\n                        return $scope.tagList.add(tag);\n                    },\n                    focusInput: function() {\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    },\n                    getTags: function() {\n                        return $scope.tags;\n                    },\n                    getCurrentTagText: function() {\n                        return $scope.newTag.text;\n                    },\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    on: function(name, handler) {\n                        $scope.events.on(name, handler);\n                        return this;\n                    }\n                };\n            };\n\n            this.registerTagItem = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    removeTag: function(index) {\n                        if ($scope.disabled) {\n                            return;\n                        }\n                        $scope.tagList.remove(index);\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, ngModelCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],\n                tagList = scope.tagList,\n                events = scope.events,\n                options = scope.options,\n                input = element.find('input'),\n                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],\n                setElementValidity;\n\n            setElementValidity = function() {\n                ngModelCtrl.$setValidity('maxTags', scope.tags.length <= options.maxTags);\n                ngModelCtrl.$setValidity('minTags', scope.tags.length >= options.minTags);\n                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text);\n            };\n\n            ngModelCtrl.$isEmpty = function(value) {\n                return !value || !value.length;\n            };\n\n            scope.newTag = {\n                text: '',\n                invalid: null,\n                setText: function(value) {\n                    this.text = value;\n                    events.trigger('input-change', value);\n                }\n            };\n\n            scope.track = function(tag) {\n                return tag[options.keyProperty || options.displayProperty];\n            };\n\n            scope.$watch('tags', function(value) {\n                scope.tags = tiUtil.makeObjectArray(value, options.displayProperty);\n                tagList.items = scope.tags;\n            });\n\n            scope.$watch('tags.length', function() {\n                setElementValidity();\n            });\n\n            attrs.$observe('disabled', function(value) {\n                scope.disabled = value;\n            });\n\n            scope.eventHandlers = {\n                input: {\n                    change: function(text) {\n                        events.trigger('input-change', text);\n                    },\n                    keydown: function($event) {\n                        events.trigger('input-keydown', $event);\n                    },\n                    focus: function() {\n                        if (scope.hasFocus) {\n                            return;\n                        }\n\n                        scope.hasFocus = true;\n                        events.trigger('input-focus');\n                    },\n                    blur: function() {\n                        $timeout(function() {\n                            var activeElement = $document.prop('activeElement'),\n                                lostFocusToBrowserWindow = activeElement === input[0],\n                                lostFocusToChildElement = element[0].contains(activeElement);\n\n                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {\n                                scope.hasFocus = false;\n                                events.trigger('input-blur');\n                            }\n                        });\n                    },\n                    paste: function($event) {\n                        $event.getTextData = function() {\n                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);\n                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');\n                        };\n                        events.trigger('input-paste', $event);\n                    }\n                },\n                host: {\n                    click: function() {\n                        if (scope.disabled) {\n                            return;\n                        }\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    }\n                }\n            };\n\n            events\n                .on('tag-added', scope.onTagAdded)\n                .on('invalid-tag', scope.onInvalidTag)\n                .on('tag-removed', scope.onTagRemoved)\n                .on('tag-added', function() {\n                    scope.newTag.setText('');\n                })\n                .on('tag-added tag-removed', function() {\n                    // Sets the element to its dirty state\n                    // In Angular 1.3 this will be replaced with $setDirty.\n                    ngModelCtrl.$setViewValue(scope.tags);\n                })\n                .on('invalid-tag', function() {\n                    scope.newTag.invalid = true;\n                })\n                .on('option-change', function(e) {\n                    if (validationOptions.indexOf(e.name) !== -1) {\n                        setElementValidity();\n                    }\n                })\n                .on('input-change', function() {\n                    tagList.clearSelection();\n                    scope.newTag.invalid = null;\n                })\n                .on('input-focus', function() {\n                    element.triggerHandler('focus');\n                    ngModelCtrl.$setValidity('leftoverText', true);\n                })\n                .on('input-blur', function() {\n                    if (options.addOnBlur && !options.addFromAutocompleteOnly) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    element.triggerHandler('blur');\n                    setElementValidity();\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        isModifier = event.shiftKey || event.altKey || event.ctrlKey || event.metaKey,\n                        addKeys = {},\n                        shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag;\n\n                    if (isModifier || hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    addKeys[KEYS.enter] = options.addOnEnter;\n                    addKeys[KEYS.comma] = options.addOnComma;\n                    addKeys[KEYS.space] = options.addOnSpace;\n\n                    shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n                    shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;\n                    shouldEditLastTag = key === KEYS.backspace && scope.newTag.text.length === 0 && options.enableEditingLastTag;\n                    shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && scope.newTag.text.length === 0 && !options.enableEditingLastTag;\n\n                    if (shouldAdd) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    else if (shouldEditLastTag) {\n                        var tag;\n\n                        tagList.selectPrior();\n                        tag = tagList.removeSelected();\n\n                        if (tag) {\n                            scope.newTag.setText(tag[options.displayProperty]);\n                        }\n                    }\n                    else if (shouldRemove) {\n                        tagList.removeSelected();\n                    }\n                    else if (shouldSelect) {\n                        if (key === KEYS.left || key === KEYS.backspace) {\n                            tagList.selectPrior();\n                        }\n                        else if (key === KEYS.right) {\n                            tagList.selectNext();\n                        }\n                    }\n\n                    if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {\n                        event.preventDefault();\n                    }\n                })\n                .on('input-paste', function(event) {\n                    if (options.addOnPaste) {\n                        var data = event.getTextData();\n                        var tags = data.split(options.pasteSplitPattern);\n\n                        if (tags.length > 1) {\n                            tags.forEach(function(tag) {\n                                tagList.addText(tag);\n                            });\n                            event.preventDefault();\n                        }\n                    }\n                });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTagItem\n * @module ngTagsInput\n *\n * @description\n * Represents a tag item. Used internally by the tagsInput directive.\n */\ntagsInput.directive('tiTagItem', [\"tiUtil\", function(tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var tagsInput = tagsInputCtrl.registerTagItem(),\n                options = tagsInput.getOptions();\n\n            scope.$$template = options.template;\n            scope.$$removeTagSymbol = options.removeTagSymbol;\n\n            scope.$getDisplayText = function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty]);\n            };\n            scope.$removeTag = function() {\n                tagsInput.removeTag(scope.$index);\n            };\n\n            scope.$watch('$parent.$index', function(value) {\n                scope.$index = value;\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name autoComplete\n * @module ngTagsInput\n *\n * @description\n * Provides autocomplete support for the tagsInput directive.\n *\n * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n *                            $query. The result of the expression must be a promise that eventually resolves to an\n *                            array of strings.\n * @param {string=} [displayProperty=text] Property to be rendered as the autocomplete label.\n * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n *                                      the source option after the last keystroke.\n * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n *                                 in the source option.\n * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n *                                               suggestions list.\n * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow\n *                                           key is pressed and the suggestion list is closed. The current input value\n *                                           is available as $query.\n * @param {boolean=} {loadOnEmpty=false} Flag indicating that the source option will be evaluated when the input content\n *                                       becomes empty. The $query variable will be passed to the expression as an empty string.\n * @param {boolean=} {loadOnFocus=false} Flag indicating that the source option will be evaluated when the input element\n *                                       gains focus. The current input value is available as $query.\n * @param {boolean=} [selectFirstMatch=true] Flag indicating that the first match will be automatically selected once\n *                                           the suggestion list is shown.\n * @param {string=} [template=] URL or id of a custom template for rendering each element of the autocomplete list.\n */\ntagsInput.directive('autoComplete', [\"$document\",\"$timeout\",\"$sce\",\"$q\",\"tagsInputConfig\",\"tiUtil\", function($document, $timeout, $sce, $q, tagsInputConfig, tiUtil) {\n    function SuggestionList(loadFn, options, events) {\n        var self = {}, getDifference, lastPromise, getTagId;\n\n        getTagId = function() {\n            return options.tagsInput.keyProperty || options.tagsInput.displayProperty;\n        };\n\n        getDifference = function(array1, array2) {\n            return array1.filter(function(item) {\n                return !tiUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {\n                    if (options.tagsInput.replaceSpacesWithDashes) {\n                        a = tiUtil.replaceSpacesWithDashes(a);\n                        b = tiUtil.replaceSpacesWithDashes(b);\n                    }\n                    return tiUtil.defaultComparer(a, b);\n                });\n            });\n        };\n\n        self.reset = function() {\n            lastPromise = null;\n\n            self.items = [];\n            self.visible = false;\n            self.index = -1;\n            self.selected = null;\n            self.query = null;\n        };\n        self.show = function() {\n            if (options.selectFirstMatch) {\n                self.select(0);\n            }\n            else {\n                self.selected = null;\n            }\n            self.visible = true;\n        };\n        self.load = tiUtil.debounce(function(query, tags) {\n            self.query = query;\n\n            var promise = $q.when(loadFn({ $query: query }));\n            lastPromise = promise;\n\n            promise.then(function(items) {\n                if (promise !== lastPromise) {\n                    return;\n                }\n\n                items = tiUtil.makeObjectArray(items.data || items, getTagId());\n                items = getDifference(items, tags);\n                self.items = items.slice(0, options.maxResultsToShow);\n\n                if (self.items.length > 0) {\n                    self.show();\n                }\n                else {\n                    self.reset();\n                }\n            });\n        }, options.debounceDelay);\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n            self.index = index;\n            self.selected = self.items[index];\n            events.trigger('suggestion-selected', index);\n        };\n\n        self.reset();\n\n        return self;\n    }\n\n    function scrollToElement(root, index) {\n        var element = root.find('li').eq(index),\n            parent = element.parent(),\n            elementTop = element.prop('offsetTop'),\n            elementHeight = element.prop('offsetHeight'),\n            parentHeight = parent.prop('clientHeight'),\n            parentScrollTop = parent.prop('scrollTop');\n\n        if (elementTop < parentScrollTop) {\n            parent.prop('scrollTop', elementTop);\n        }\n        else if (elementTop + elementHeight > parentHeight + parentScrollTop) {\n            parent.prop('scrollTop', elementTop + elementHeight - parentHeight);\n        }\n    }\n\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        scope: { source: '&' },\n        templateUrl: 'ngTagsInput/auto-complete.html',\n        controller: [\"$scope\",\"$element\",\"$attrs\", function($scope, $element, $attrs) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('autoComplete', $scope, $attrs, {\n                template: [String, 'ngTagsInput/auto-complete-match.html'],\n                debounceDelay: [Number, 100],\n                minLength: [Number, 3],\n                highlightMatchedText: [Boolean, true],\n                maxResultsToShow: [Number, 10],\n                loadOnDownArrow: [Boolean, false],\n                loadOnEmpty: [Boolean, false],\n                loadOnFocus: [Boolean, false],\n                selectFirstMatch: [Boolean, true],\n                displayProperty: [String, '']\n            });\n\n            $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);\n\n            this.registerAutocompleteMatch = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    getQuery: function() {\n                        return $scope.suggestionList.query;\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n                suggestionList = scope.suggestionList,\n                tagsInput = tagsInputCtrl.registerAutocomplete(),\n                options = scope.options,\n                events = scope.events,\n                shouldLoadSuggestions;\n\n            options.tagsInput = tagsInput.getOptions();\n\n            shouldLoadSuggestions = function(value) {\n                return value && value.length >= options.minLength || !value && options.loadOnEmpty;\n            };\n\n            scope.addSuggestionByIndex = function(index) {\n                suggestionList.select(index);\n                scope.addSuggestion();\n            };\n\n            scope.addSuggestion = function() {\n                var added = false;\n\n                if (suggestionList.selected) {\n                    tagsInput.addTag(angular.copy(suggestionList.selected));\n                    suggestionList.reset();\n                    tagsInput.focusInput();\n\n                    added = true;\n                }\n                return added;\n            };\n\n            scope.track = function(item) {\n                return item[options.tagsInput.keyProperty || options.tagsInput.displayProperty];\n            };\n\n            tagsInput\n                .on('tag-added invalid-tag input-blur', function() {\n                    suggestionList.reset();\n                })\n                .on('input-change', function(value) {\n                    if (shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                    else {\n                        suggestionList.reset();\n                    }\n                })\n                .on('input-focus', function() {\n                    var value = tagsInput.getCurrentTagText();\n                    if (options.loadOnFocus && shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        handled = false;\n\n                    if (hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    if (suggestionList.visible) {\n\n                        if (key === KEYS.down) {\n                            suggestionList.selectNext();\n                            handled = true;\n                        }\n                        else if (key === KEYS.up) {\n                            suggestionList.selectPrior();\n                            handled = true;\n                        }\n                        else if (key === KEYS.escape) {\n                            suggestionList.reset();\n                            handled = true;\n                        }\n                        else if (key === KEYS.enter || key === KEYS.tab) {\n                            handled = scope.addSuggestion();\n                        }\n                    }\n                    else {\n                        if (key === KEYS.down && scope.options.loadOnDownArrow) {\n                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());\n                            handled = true;\n                        }\n                    }\n\n                    if (handled) {\n                        event.preventDefault();\n                        event.stopImmediatePropagation();\n                        return false;\n                    }\n                });\n\n            events.on('suggestion-selected', function(index) {\n                scrollToElement(element, index);\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiAutocompleteMatch\n * @module ngTagsInput\n *\n * @description\n * Represents an autocomplete match. Used internally by the autoComplete directive.\n */\ntagsInput.directive('tiAutocompleteMatch', [\"$sce\",\"tiUtil\", function($sce, tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^autoComplete',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, autoCompleteCtrl) {\n            var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),\n                options = autoComplete.getOptions();\n\n            scope.$$template = options.template;\n            scope.$index = scope.$parent.$index;\n\n            scope.$highlight = function(text) {\n                if (options.highlightMatchedText) {\n                    text = tiUtil.safeHighlight(text, autoComplete.getQuery());\n                }\n                return $sce.trustAsHtml(text);\n            };\n            scope.$getDisplayText =  function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty || options.tagsInput.displayProperty]);\n            };\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTranscludeAppend\n * @module ngTagsInput\n *\n * @description\n * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiTranscludeAppend', function() {\n    return function(scope, element, attrs, ctrl, transcludeFn) {\n        transcludeFn(function(clone) {\n            element.append(clone);\n        });\n    };\n});\n\n/**\n * @ngdoc directive\n * @name tiAutosize\n * @module ngTagsInput\n *\n * @description\n * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiAutosize', [\"tagsInputConfig\", function(tagsInputConfig) {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, element, attrs, ctrl) {\n            var threshold = tagsInputConfig.getTextAutosizeThreshold(),\n                span, resize;\n\n            span = angular.element('<span class=\"input\"></span>');\n            span.css('display', 'none')\n                .css('visibility', 'hidden')\n                .css('width', 'auto')\n                .css('white-space', 'pre');\n\n            element.parent().append(span);\n\n            resize = function(originalValue) {\n                var value = originalValue, width;\n\n                if (angular.isString(value) && value.length === 0) {\n                    value = attrs.placeholder;\n                }\n\n                if (value) {\n                    span.text(value);\n                    span.css('display', '');\n                    width = span.prop('offsetWidth');\n                    span.css('display', 'none');\n                }\n\n                element.css('width', width ? width + threshold + 'px' : '');\n\n                return originalValue;\n            };\n\n            ctrl.$parsers.unshift(resize);\n            ctrl.$formatters.unshift(resize);\n\n            attrs.$observe('placeholder', function(value) {\n                if (!ctrl.$modelValue) {\n                    resize(value);\n                }\n            });\n        }\n    };\n}]);\n\n/**\n * @ngdoc directive\n * @name tiBindAttrs\n * @module ngTagsInput\n *\n * @description\n * Binds attributes to expressions. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiBindAttrs', function() {\n    return function(scope, element, attrs) {\n        scope.$watch(attrs.tiBindAttrs, function(value) {\n            angular.forEach(value, function(value, key) {\n                /**\n                 * blake_r - Added to work around the version of jQuery that\n                 * MAAS currently ships with. Once packaging for jQuery is\n                 * version >1.9 this can be removed.\n                 */\n                if(key === \"type\") {\n                    element[0].type = value;\n                } else {\n                    attrs.$set(key, value);\n                }\n            });\n        }, true);\n    };\n});\n\n/**\n * @ngdoc service\n * @name tagsInputConfig\n * @module ngTagsInput\n *\n * @description\n * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n * initialize options from HTML attributes.\n */\ntagsInput.provider('tagsInputConfig', function() {\n    var globalDefaults = {},\n        interpolationStatus = {},\n        autosizeThreshold = 3;\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function(directive, defaults) {\n        globalDefaults[directive] = defaults;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function(directive, options) {\n        interpolationStatus[directive] = options;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setTextAutosizeThreshold\n     * @description Sets the threshold used by the tagsInput directive to re-size the inner input field element based on its contents.\n     * @methodOf tagsInputConfig\n     *\n     * @param {number} threshold Threshold value, in pixels.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setTextAutosizeThreshold = function(threshold) {\n        autosizeThreshold = threshold;\n        return this;\n    };\n\n    this.$get = [\"$interpolate\", function($interpolate) {\n        var converters = {};\n        converters[String] = function(value) { return value; };\n        converters[Number] = function(value) { return parseInt(value, 10); };\n        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };\n        converters[RegExp] = function(value) { return new RegExp(value); };\n\n        return {\n            load: function(directive, scope, attrs, options) {\n                var defaultValidator = function() { return true; };\n\n                scope.options = {};\n\n                angular.forEach(options, function(value, key) {\n                    var type, localDefault, validator, converter, getDefault, updateValue;\n\n                    type = value[0];\n                    localDefault = value[1];\n                    validator = value[2] || defaultValidator;\n                    converter = converters[type];\n\n                    getDefault = function() {\n                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n                        return angular.isDefined(globalValue) ? globalValue : localDefault;\n                    };\n\n                    updateValue = function(value) {\n                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();\n                    };\n\n                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {\n                        attrs.$observe(key, function(value) {\n                            updateValue(value);\n                            scope.events.trigger('option-change', { name: key, newValue: value });\n                        });\n                    }\n                    else {\n                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n                    }\n                });\n            },\n            getTextAutosizeThreshold: function() {\n                return autosizeThreshold;\n            }\n        };\n    }];\n});\n\n\n/***\n * @ngdoc factory\n * @name tiUtil\n * @module ngTagsInput\n *\n * @description\n * Helper methods used internally by the directive. Should not be called directly from user code.\n */\ntagsInput.factory('tiUtil', [\"$timeout\", function($timeout) {\n    var self = {};\n\n    self.debounce = function(fn, delay) {\n        var timeoutId;\n        return function() {\n            var args = arguments;\n            $timeout.cancel(timeoutId);\n            timeoutId = $timeout(function() { fn.apply(null, args); }, delay);\n        };\n    };\n\n    self.makeObjectArray = function(array, key) {\n        array = array || [];\n        if (array.length > 0 && !angular.isObject(array[0])) {\n            array.forEach(function(item, index) {\n                array[index] = {};\n                array[index][key] = item;\n            });\n        }\n        return array;\n    };\n\n    self.findInObjectArray = function(array, obj, key, comparer) {\n        var item = null;\n        comparer = comparer || self.defaultComparer;\n\n        array.some(function(element) {\n            if (comparer(element[key], obj[key])) {\n                item = element;\n                return true;\n            }\n        });\n\n        return item;\n    };\n\n    self.defaultComparer = function(a, b) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();\n    };\n\n    self.safeHighlight = function(str, value) {\n        if (!value) {\n            return str;\n        }\n\n        function escapeRegexChars(str) {\n            return str.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n        }\n\n        str = self.encodeHTML(str);\n        value = self.encodeHTML(value);\n\n        var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');\n        return str.replace(expression, function(match) {\n            return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;\n        });\n    };\n\n    self.safeToString = function(value) {\n        return angular.isUndefined(value) || value == null ? '' : value.toString().trim();\n    };\n\n    self.encodeHTML = function(value) {\n        return self.safeToString(value)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    };\n\n    self.handleUndefinedResult = function(fn, valueIfUndefined) {\n        return function() {\n            var result = fn.apply(null, arguments);\n            return angular.isUndefined(result) ? valueIfUndefined : result;\n        };\n    };\n\n    self.replaceSpacesWithDashes = function(str) {\n        return self.safeToString(str).replace(/\\s/g, '-');\n    };\n\n    self.simplePubSub = function() {\n        var events = {};\n        return {\n            on: function(names, handler) {\n                names.split(' ').forEach(function(name) {\n                    if (!events[name]) {\n                        events[name] = [];\n                    }\n                    events[name].push(handler);\n                });\n                return this;\n            },\n            trigger: function(name, args) {\n                var handlers = events[name] || [];\n                handlers.every(function(handler) {\n                    return self.handleUndefinedResult(handler, true)(args);\n                });\n                return this;\n            }\n        };\n    };\n\n    return self;\n}]);\n\n/* HTML templates */\ntagsInput.run([\"$templateCache\", function($templateCache) {\n    $templateCache.put('ngTagsInput/tags-input.html',\n    \"<div class=\\\"host\\\" tabindex=\\\"-1\\\" data-ng-click=\\\"eventHandlers.host.click()\\\" ti-transclude-append=\\\"\\\"><div class=\\\"tags\\\" data-ng-class=\\\"{focused: hasFocus}\\\"><ul class=\\\"tag-list\\\"><li class=\\\"tag-item\\\" data-ng-repeat=\\\"tag in tagList.items track by track(tag)\\\" data-ng-class=\\\"{ selected: tag == tagList.selected }\\\"><ti-tag-item data=\\\"tag\\\"></ti-tag-item></li></ul><input class=\\\"input u-no-margin--top\\\" autocomplete=\\\"off\\\" data-ng-model=\\\"newTag.text\\\" data-ng-change=\\\"eventHandlers.input.change(newTag.text)\\\" data-ng-keydown=\\\"eventHandlers.input.keydown($event)\\\" data-ng-focus=\\\"eventHandlers.input.focus($event)\\\" data-ng-blur=\\\"eventHandlers.input.blur($event)\\\" data-ng-paste=\\\"eventHandlers.input.paste($event)\\\" data-ng-trim=\\\"false\\\" data-ng-class=\\\"{'invalid-tag': newTag.invalid}\\\" data-ng-disabled=\\\"disabled\\\" ti-bind-attrs=\\\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\\\" ti-autosize=\\\"\\\"></div></div>\"\n  );\n\n  $templateCache.put('ngTagsInput/tag-item.html',\n    \"<span ng-bind=\\\"$getDisplayText()\\\"></span> <a class=\\\"p-icon--close\\\" data-ng-click=\\\"$removeTag()\\\" data-ng-bind=\\\"$$removeTagSymbol\\\">Remove tag</a>\"\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete.html',\n    \"<div class=\\\"autocomplete\\\" data-ng-if=\\\"suggestionList.visible\\\"><ul class=\\\"p-list suggestion-list\\\"><li class=\\\"suggestion-item\\\" data-ng-repeat=\\\"item in suggestionList.items track by track(item)\\\" data-ng-class=\\\"{selected: item == suggestionList.selected}\\\" data-ng-click=\\\"addSuggestionByIndex($index)\\\" data-ng-mouseenter=\\\"suggestionList.select($index)\\\"><ti-autocomplete-match data=\\\"item\\\"></ti-autocomplete-match></li></ul></div>\"\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete-match.html',\n    \"<span data-ng-bind-html=\\\"$highlight($getDisplayText())\\\"></span>\"\n  );\n}]);\n\n}());\n","/*!\n * Angular Virtual Scroll Repeat v2.0.9\n * https://github.com/kamilkp/angular-vs-repeat/\n *\n * Copyright Kamil PÄ™kala\n * http://github.com/kamilkp\n *\n * Released under the MIT License\n * https://opensource.org/licenses/MIT\n *\n * Date: 2018/04/02\n */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }\n\n/* global console, setTimeout, module */\n(function (window, angular) {\n  /**\n   * DESCRIPTION:\n   * vsRepeat directive stands for Virtual Scroll Repeat. It turns a standard ngRepeated set of elements in a scrollable container\n   * into a component, where the user thinks he has all the elements rendered and all he needs to do is scroll (without any kind of\n   * pagination - which most users loath) and at the same time the browser isn't overloaded by that many elements/angular bindings etc.\n   * The directive renders only so many elements that can fit into current container's clientHeight/clientWidth.\n    * LIMITATIONS:\n   * - current version only supports an Array as a right-hand-side object for ngRepeat\n   * - all rendered elements must have the same height/width or the sizes of the elements must be known up front\n    * USAGE:\n   * In order to use the vsRepeat directive you need to place a vs-repeat attribute on a direct parent of an element with ng-repeat\n   * example:\n   * <div vs-repeat=\"options\">\n   *      <div ng-repeat=\"item in someArray\">\n   *          <!-- content -->\n   *      </div>\n   * </div>\n    * or:\n   * <div vs-repeat=\"options\">\n   *      <div ng-repeat-start=\"item in someArray\">\n   *          <!-- content -->\n   *      </div>\n   *      <div>\n   *         <!-- something in the middle -->\n   *      </div>\n   *      <div ng-repeat-end>\n   *          <!-- content -->\n   *      </div>\n   * </div>\n    * You can also measure the single element's height/width (including all paddings and margins), and then speficy it as a value\n   * of the option's `size` property. This can be used if one wants to override the automatically computed element size.\n   * example:\n   * <div vs-repeat=\"{size: 50}\"> <!-- the specified element height is 50px -->\n   *      <div ng-repeat=\"item in someArray\">\n   *          <!-- content -->\n   *      </div>\n   * </div>\n    * IMPORTANT!\n    * - the vsRepeat directive must be applied to a direct parent of an element with ngRepeat\n   * - the value of vsRepeat attribute is the single element's height/width measured in pixels. If none provided, the directive\n   *      will compute it automatically\n    * OPTIONAL PARAMETERS (attributes):\n   * vs-repeat-container=\"selector\" - selector for element containing ng-repeat. (defaults to the current element)\n    * OPTIONS:\n   * Options shall be passed as an object to the `vs-repeat` attribute e.g.: `<div vs-repeat=\"{scrollParent: 'window', size: 20}\"></div>`\n   *\n   * Available options:\n   * `horizontal` - stack repeated elements horizontally instead of vertically\n   * `offset-before` - top/left offset in pixels (defaults to 0)\n   * `offset-after` - bottom/right offset in pixels (defaults to 0)\n   * `scroll-margin` - how many pixels ahead should elements be rendered while scrolling\n   * `latch` - if true, elements will be rendered gradually but won't be removed when scrolled away (defaults to false)\n    * `size` - a property name of the items in collection that is a number denoting the element size (in pixels)\n   * `autoresize` - use this attribute without vs-size and without specifying element's size. The automatically computed element style will\n   *              readjust upon window resize if the size is dependable on the viewport size\n   * `scrolled-to-end` - callback will be called when the last item of the list is rendered\n   * `scrolled-to-end-offset` - set this number to trigger the scrolledToEnd callback n items before the last gets rendered\n   * `scrolled-to-beginning` - callback will be called when the first item of the list is rendered\n   * `scrolled-to-beginning-offset` - set this number to trigger the scrolledToBeginning callback n items before the first gets rendered\n    * EVENTS:\n   * - `vsRepeatTrigger` - an event the directive listens for to manually trigger reinitialization\n   * - `vsRepeatReinitialized` - an event the directive emits upon reinitialization done\n   */\n  var closestElement = angular.element.prototype.closest;\n\n  if (!closestElement) {\n    var matchingFunction = ['matches', 'matchesSelector', 'webkitMatches', 'webkitMatchesSelector', 'msMatches', 'msMatchesSelector', 'mozMatches', 'mozMatchesSelector'].reduce(function (res, prop) {\n      var _res;\n\n      return (_res = res) !== null && _res !== void 0 ? _res : prop in document.documentElement ? prop : null;\n    }, null);\n\n    closestElement = function closestElement(selector) {\n      var _el;\n\n      var el = this[0].parentNode;\n\n      while (el !== document.documentElement && el != null && !el[matchingFunction](selector)) {\n        el = el.parentNode;\n      }\n\n      if ((_el = el) === null || _el === void 0 ? void 0 : _el[matchingFunction](selector)) {\n        return angular.element(el);\n      }\n\n      return angular.element();\n    };\n  }\n\n  function getWindowScroll() {\n    var _ref, _document$documentEle, _ref2, _document$documentEle2;\n\n    if ('pageYOffset' in window) {\n      return {\n        scrollTop: window.pageYOffset,\n        scrollLeft: window.pageXOffset\n      };\n    }\n\n    return {\n      scrollTop: (_ref = (_document$documentEle = document.documentElement.scrollTop) !== null && _document$documentEle !== void 0 ? _document$documentEle : document.body.scrollTop) !== null && _ref !== void 0 ? _ref : 0,\n      scrollLeft: (_ref2 = (_document$documentEle2 = document.documentElement.scrollLeft) !== null && _document$documentEle2 !== void 0 ? _document$documentEle2 : document.body.scrollLeft) !== null && _ref2 !== void 0 ? _ref2 : 0\n    };\n  }\n\n  function getClientSize(element, sizeProp) {\n    if (element === window) {\n      return sizeProp === 'clientWidth' ? window.innerWidth : window.innerHeight;\n    }\n\n    return element[sizeProp];\n  }\n\n  function getScrollPos(element, scrollProp) {\n    return element === window ? getWindowScroll()[scrollProp] : element[scrollProp];\n  }\n\n  function getScrollOffset(vsElement, scrollElement, isHorizontal) {\n    var vsPos = vsElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n    var scrollPos = scrollElement === window ? 0 : scrollElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n    var scrollValue = (scrollElement === window ? getWindowScroll() : scrollElement)[isHorizontal ? 'scrollLeft' : 'scrollTop'];\n    return vsPos - scrollPos + scrollValue;\n  }\n\n  function analyzeNgRepeatUsage(element) {\n    var options = ['ng-repeat', 'data-ng-repeat', 'ng-repeat-start', 'data-ng-repeat-start'];\n\n    for (var _i = 0; _i < options.length; _i++) {\n      var opt = options[_i];\n\n      if (element.attr(opt)) {\n        return [opt, element.attr(opt), opt.indexOf('-start') >= 0];\n      }\n    }\n\n    throw new Error('angular-vs-repeat: no ng-repeat directive on a child element');\n  }\n\n  function printDeprecationWarning($element, message) {\n    console.warn(\"vs-repeat deprecation: \".concat(message), $element[0]);\n  }\n\n  function attrDeprecated(attrname, $element) {\n    printDeprecationWarning($element, \"\".concat(attrname, \" attribute is deprecated. Pass the options object to vs-repeat attribute instead https://github.com/kamilkp/angular-vs-repeat#options\"));\n  }\n\n  var defaultOptions = {\n    latch: false,\n    container: null,\n    scrollParent: null,\n    size: null,\n    offsetBefore: 0,\n    offsetAfter: 0,\n    scrolledToBeginning: angular.noop,\n    scrolledToEnd: angular.noop,\n    scrolledToBeginningOffset: 0,\n    scrolledToEndOffset: 0,\n    scrollMargin: 0,\n    horizontal: false,\n    autoresize: false,\n    hunked: false,\n    hunkSize: 0\n  };\n  var vsRepeatModule = angular.module('vs-repeat', []).directive('vsRepeat', ['$compile', '$parse', function ($compile, $parse) {\n    return {\n      restrict: 'A',\n      scope: true,\n      compile: function compile(compileElement, compileAttrs) {\n        var compileRepeatContainer = 'vsRepeatContainer' in compileAttrs ? angular.element(compileElement[0].querySelector(compileAttrs.vsRepeatContainer)) : compileElement;\n        var repeatContainerChildren = compileRepeatContainer.children();\n        var ngRepeatChild = repeatContainerChildren.eq(0);\n        var childCloneHtml = ngRepeatChild[0].outerHTML;\n        var collectionName = '$vs_collection'; // TODO: make configurable?\n\n        ['vsSize', 'vsScrollParent', 'vsSizeProperty', 'vsHorizontal', 'vsOffsetBefore', 'vsOffsetAfter', 'vsScrolledToEndOffset', 'vsScrolledToBeginningOffset', 'vsExcess', 'vsScrollMargin'].forEach(function (attrname) {\n          if (attrname in compileAttrs) {\n            attrDeprecated(attrname, compileElement);\n          }\n        });\n\n        var _analyzeNgRepeatUsage = analyzeNgRepeatUsage(ngRepeatChild),\n            _analyzeNgRepeatUsage2 = _slicedToArray(_analyzeNgRepeatUsage, 3),\n            originalNgRepeatAttr = _analyzeNgRepeatUsage2[0],\n            ngRepeatExpression = _analyzeNgRepeatUsage2[1],\n            isNgRepeatStart = _analyzeNgRepeatUsage2[2];\n\n        var expressionMatches = /^\\s*(\\S+)\\s+in\\s+([\\S\\s]+?)(track\\s+by\\s+\\S+)?$/.exec(ngRepeatExpression);\n\n        var _expressionMatches = _slicedToArray(expressionMatches, 4),\n            lhs = _expressionMatches[1],\n            rhs = _expressionMatches[2],\n            rhsSuffix = _expressionMatches[3];\n\n        if (isNgRepeatStart) {\n          var index = 0;\n          var repeaterElement = repeatContainerChildren.eq(index);\n\n          while (repeaterElement.attr('ng-repeat-end') == null && repeaterElement.attr('data-ng-repeat-end') == null) {\n            index++;\n            repeaterElement = repeatContainerChildren.eq(index);\n            childCloneHtml += repeaterElement[0].outerHTML;\n          }\n        }\n\n        compileRepeatContainer.empty();\n        return {\n          pre: function pre($scope, $element, $attrs) {\n            var _$scope$$eval;\n\n            function _parseSize(options) {\n              if (typeof options.size === 'number') {\n                options.getSize = function () {\n                  return options.size;\n                };\n              } else {\n                var parsed = $parse(String(options.size));\n\n                options.getSize = function (item) {\n                  return parsed($scope, _defineProperty({}, lhs, item));\n                };\n              }\n            }\n\n            $scope.vsRepeat = {\n              options: _extends({}, defaultOptions, (_$scope$$eval = $scope.$eval($attrs.vsRepeat)) !== null && _$scope$$eval !== void 0 ? _$scope$$eval : {})\n            };\n            var options = $scope.vsRepeat.options;\n\n            _parseSize(options);\n\n            var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element;\n            var childClone = angular.element(childCloneHtml);\n            var childTagName = childClone[0].tagName.toLowerCase();\n            var originalCollection = [];\n            var originalLength;\n            var $beforeContent = angular.element('<' + childTagName + ' class=\"vs-repeat-before-content\"></' + childTagName + '>');\n            var $afterContent = angular.element('<' + childTagName + ' class=\"vs-repeat-after-content\"></' + childTagName + '>');\n            var autosizingRequired = options.size === null;\n            var $scrollParent = options.scrollParent ? options.scrollParent === 'window' ? angular.element(window) : closestElement.call(repeatContainer, options.scrollParent) : repeatContainer;\n            var clientSize = options.horizontal ? 'clientWidth' : 'clientHeight';\n            var offsetSize = options.horizontal ? 'offsetWidth' : 'offsetHeight';\n            var scrollSize = options.horizontal ? 'scrollWidth' : 'scrollHeight';\n            var scrollPos = options.horizontal ? 'scrollLeft' : 'scrollTop';\n            $scope.vsRepeat.totalSize = 0;\n\n            if ($scrollParent.length === 0) {\n              throw 'Specified scroll parent selector did not match any element';\n            }\n\n            $scope.vsRepeat.$scrollParent = $scrollParent;\n            $scope.vsRepeat.sizesCumulative = [];\n\n            if (options.debug) {\n              var $debugParent = options.scrollParent === 'window' ? angular.element(document.body) : $scrollParent;\n              var $debug = angular.element('<div class=\"vs-repeat-debug-element\"></div>');\n              $debug.css('position', options.scrollParent === 'window' ? 'fixed' : 'absolute');\n              $debugParent.append($debug);\n              $scope.$on('$destroy', function () {\n                $debug.remove();\n              });\n            }\n\n            var measuredSize = getClientSize($scrollParent[0], clientSize) || 50;\n\n            if (options.horizontal) {\n              $beforeContent.css('height', '100%');\n              $afterContent.css('height', '100%');\n            } else {\n              $beforeContent.css('width', '100%');\n              $afterContent.css('width', '100%');\n            }\n\n            if ($attrs.vsRepeatOptions) {\n              $scope.$watchCollection($attrs.vsRepeatOptions, function (newOpts) {\n                var mergedOptions = _extends({}, options, newOpts);\n\n                if (JSON.stringify(mergedOptions) !== JSON.stringify(options)) {\n                  Object.assign(options, newOpts);\n\n                  _parseSize(options);\n\n                  reinitialize();\n                }\n              });\n            }\n\n            $scope.$watchCollection(rhs, function () {\n              var coll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n              originalCollection = coll;\n              refresh();\n            });\n\n            function refresh() {\n              if (!originalCollection || originalCollection.length < 1) {\n                $scope[collectionName] = [];\n                originalLength = 0;\n                $scope.vsRepeat.sizesCumulative = [0];\n              } else {\n                originalLength = originalCollection.length;\n\n                if (options.size) {\n                  _mapSize();\n                } else {\n                  getFromMeasured();\n                }\n              }\n\n              reinitialize();\n            }\n\n            function _mapSize() {\n              var hardSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n              var sizes = originalCollection.map(function (item) {\n                var _hardSize;\n\n                return (_hardSize = hardSize) !== null && _hardSize !== void 0 ? _hardSize : options.getSize(item);\n              });\n              var sum = 0;\n              $scope.vsRepeat.sizesCumulative = [0].concat(_toConsumableArray(sizes.map(function (size) {\n                return sum += size;\n              })));\n            }\n\n            function getFromMeasured() {\n              if (autosizingRequired) {\n                $scope.$$postDigest(function () {\n                  if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) {\n                    // element is visible\n                    var children = repeatContainer.children();\n                    var i = 0;\n                    var gotSomething = false;\n                    var insideStartEndSequence = false;\n\n                    while (i < children.length) {\n                      if (children[i].attributes[originalNgRepeatAttr] != null || insideStartEndSequence) {\n                        if (!gotSomething) {\n                          measuredSize = 0;\n                        }\n\n                        gotSomething = true;\n\n                        if (children[i][offsetSize]) {\n                          measuredSize += children[i][offsetSize];\n                        }\n\n                        if (isNgRepeatStart) {\n                          if (children[i].attributes['ng-repeat-end'] != null || children[i].attributes['data-ng-repeat-end'] != null) {\n                            break;\n                          } else {\n                            insideStartEndSequence = true;\n                          }\n                        } else {\n                          break;\n                        }\n                      }\n\n                      i++;\n                    }\n\n                    if (gotSomething) {\n                      _mapSize(measuredSize);\n\n                      reinitialize();\n                      autosizingRequired = false;\n\n                      if ($scope.$root && !$scope.$root.$$phase) {\n                        $scope.$digest();\n                      }\n                    }\n                  } else {\n                    var dereg = $scope.$watch(function () {\n                      if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) {\n                        dereg();\n                        getFromMeasured();\n                      }\n                    });\n                  }\n                });\n              } else {\n                _mapSize(measuredSize);\n              }\n            }\n\n            function getLayoutProps(value) {\n              var layoutProp = options.horizontal ? 'width' : 'height';\n              return ['', 'min-', 'max-'].reduce(function (acc, prop) {\n                return acc[\"\".concat(prop).concat(layoutProp)] = value, acc;\n              }, {});\n            }\n\n            childClone.eq(0).attr(originalNgRepeatAttr, lhs + ' in ' + collectionName + (rhsSuffix ? ' ' + rhsSuffix : ''));\n            childClone.addClass('vs-repeat-repeated-element');\n            repeatContainer.append($beforeContent);\n            repeatContainer.append(childClone);\n            $compile(childClone)($scope);\n            repeatContainer.append($afterContent);\n            $scope.vsRepeat.startIndex = 0;\n            $scope.vsRepeat.endIndex = 0;\n\n            function scrollHandler() {\n              var pos = $scrollParent[0][scrollPos];\n\n              if (updateInnerCollection()) {\n                $scope.$digest();\n\n                if (options._ensureScrollIntegrity) {\n                  $scrollParent[0][scrollPos] = pos;\n                }\n              }\n            }\n\n            $scrollParent.on('scroll', scrollHandler);\n\n            function onWindowResize() {\n              if (options.autoresize) {\n                autosizingRequired = true;\n                getFromMeasured();\n\n                if ($scope.$root && !$scope.$root.$$phase) {\n                  $scope.$digest();\n                }\n              }\n\n              if (updateInnerCollection()) {\n                $scope.$digest();\n              }\n            }\n\n            angular.element(window).on('resize', onWindowResize);\n            $scope.$on('$destroy', function () {\n              angular.element(window).off('resize', onWindowResize);\n              $scrollParent.off('scroll', scrollHandler);\n            });\n            $scope.$on('vsRepeatTrigger', refresh);\n            $scope.$on('vsRepeatResize', function () {\n              autosizingRequired = true;\n              getFromMeasured();\n            });\n\n            var _prevStartIndex, _prevEndIndex, _minStartIndex, _maxEndIndex;\n\n            $scope.$on('vsRenderAll', function () {\n              if (!options.latch) {\n                return;\n              }\n\n              if ($scope.vsRepeat.endIndex === originalLength) {\n                $scope.$emit('vsRenderAllDone');\n                return;\n              }\n\n              setTimeout(function () {\n                // var __endIndex = Math.min($scope.vsRepeat.endIndex + (quantum || 1), originalLength);\n                var __endIndex = originalLength;\n                _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n                $scope.vsRepeat.endIndex = options.latch ? _maxEndIndex : __endIndex;\n                $scope[collectionName] = originalCollection.slice($scope.vsRepeat.startIndex, $scope.vsRepeat.endIndex);\n                _prevEndIndex = $scope.vsRepeat.endIndex;\n                $beforeContent.css(getLayoutProps(0));\n                $afterContent.css(getLayoutProps(0));\n                $scope.$emit('vsRenderAllDone');\n\n                if ($scope.$root && !$scope.$root.$$phase) {\n                  $scope.$digest();\n                }\n              });\n            });\n\n            function reinitialize() {\n              _prevStartIndex = void 0;\n              _prevEndIndex = void 0;\n              _minStartIndex = originalLength;\n              _maxEndIndex = 0;\n              updateTotalSize($scope.vsRepeat.sizesCumulative[originalLength]);\n              updateInnerCollection();\n              $scope.$emit('vsRepeatReinitialized', $scope.vsRepeat.startIndex, $scope.vsRepeat.endIndex);\n            }\n\n            function updateTotalSize(size) {\n              $scope.vsRepeat.totalSize = options.offsetBefore + size + options.offsetAfter;\n            }\n\n            var _prevClientSize;\n\n            function reinitOnClientHeightChange() {\n              var ch = getClientSize($scrollParent[0], clientSize);\n\n              if (ch !== _prevClientSize) {\n                reinitialize();\n\n                if ($scope.$root && !$scope.$root.$$phase) {\n                  $scope.$digest();\n                }\n              }\n\n              _prevClientSize = ch;\n            }\n\n            $scope.$watch(function () {\n              if (typeof window.requestAnimationFrame === 'function') {\n                window.requestAnimationFrame(reinitOnClientHeightChange);\n              } else {\n                reinitOnClientHeightChange();\n              }\n            });\n\n            function binaryFind(array, threshold) {\n              var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n              var b = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length - 1;\n              var d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n              if (array[a] === threshold) {\n                return [a, a, d];\n              }\n\n              if (array[b] === threshold) {\n                return [b, b, d];\n              }\n\n              if (b - a > 1) {\n                var m = Math.floor((a + b) / 2);\n\n                if (array[m] > threshold) {\n                  return binaryFind(array, threshold, a, m, d + 1);\n                }\n\n                return binaryFind(array, threshold, m, b, d + 1);\n              }\n\n              return [threshold > array[b] ? b : a, threshold < array[a] ? a : b, d];\n            }\n\n            function updateInnerCollection() {\n              var $scrollPosition = getScrollPos($scrollParent[0], scrollPos);\n              var $clientSize = getClientSize($scrollParent[0], clientSize);\n\n              if (options.debug) {\n                $clientSize /= 2;\n              }\n\n              var scrollOffset = repeatContainer[0] === $scrollParent[0] ? 0 : getScrollOffset(repeatContainer[0], $scrollParent[0], options.horizontal);\n              var __startIndex = $scope.vsRepeat.startIndex;\n              var __endIndex = $scope.vsRepeat.endIndex;\n\n              if (autosizingRequired && !options.size) {\n                __startIndex = 0;\n                __endIndex = 1;\n              } else {\n                _warnMismatch();\n\n                var relativeScroll = $scrollPosition - options.offsetBefore - scrollOffset;\n\n                var _binaryFind = binaryFind($scope.vsRepeat.sizesCumulative, relativeScroll - options.scrollMargin);\n\n                var _binaryFind2 = _slicedToArray(_binaryFind, 1);\n\n                __startIndex = _binaryFind2[0];\n                __startIndex = Math.max(__startIndex, 0);\n\n                var _binaryFind3 = binaryFind($scope.vsRepeat.sizesCumulative, relativeScroll + options.scrollMargin + $clientSize, __startIndex);\n\n                var _binaryFind4 = _slicedToArray(_binaryFind3, 2);\n\n                __endIndex = _binaryFind4[1];\n                __endIndex = Math.min(__endIndex, originalLength);\n              }\n\n              _minStartIndex = Math.min(__startIndex, _minStartIndex);\n              _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n              $scope.vsRepeat.startIndex = options.latch ? _minStartIndex : __startIndex;\n              $scope.vsRepeat.endIndex = options.latch ? _maxEndIndex : __endIndex; // Move to the end of the collection if we are now past it\n\n              if (_maxEndIndex < $scope.vsRepeat.startIndex) $scope.vsRepeat.startIndex = _maxEndIndex;\n              var digestRequired = false;\n\n              if (_prevStartIndex == null) {\n                digestRequired = true;\n              } else if (_prevEndIndex == null) {\n                digestRequired = true;\n              }\n\n              if (!digestRequired) {\n                if (options.hunked) {\n                  if (Math.abs($scope.vsRepeat.startIndex - _prevStartIndex) >= options.hunkSize || $scope.vsRepeat.startIndex === 0 && _prevStartIndex !== 0) {\n                    digestRequired = true;\n                  } else if (Math.abs($scope.vsRepeat.endIndex - _prevEndIndex) >= options.hunkSize || $scope.vsRepeat.endIndex === originalLength && _prevEndIndex !== originalLength) {\n                    digestRequired = true;\n                  }\n                } else {\n                  digestRequired = $scope.vsRepeat.startIndex !== _prevStartIndex || $scope.vsRepeat.endIndex !== _prevEndIndex;\n                }\n              }\n\n              if (digestRequired) {\n                $scope[collectionName] = originalCollection.slice($scope.vsRepeat.startIndex, $scope.vsRepeat.endIndex); // Emit the event\n\n                $scope.$emit('vsRepeatInnerCollectionUpdated', $scope.vsRepeat.startIndex, $scope.vsRepeat.endIndex, _prevStartIndex, _prevEndIndex);\n                var triggerIndex;\n\n                if (options.scrolledToEnd) {\n                  triggerIndex = originalCollection.length - options.scrolledToEndOffset;\n\n                  if ($scope.vsRepeat.endIndex >= triggerIndex && _prevEndIndex < triggerIndex || originalCollection.length && $scope.vsRepeat.endIndex === originalCollection.length) {\n                    $scope.$eval(options.scrolledToEnd);\n                  }\n                }\n\n                if (options.scrolledToBeginning) {\n                  triggerIndex = options.scrolledToBeginningOffset;\n\n                  if ($scope.vsRepeat.startIndex <= triggerIndex && _prevStartIndex > $scope.vsRepeat.startIndex) {\n                    $scope.$eval(options.scrolledToBeginning);\n                  }\n                }\n\n                _prevStartIndex = $scope.vsRepeat.startIndex;\n                _prevEndIndex = $scope.vsRepeat.endIndex;\n                var o1 = $scope.vsRepeat.sizesCumulative[$scope.vsRepeat.startIndex] + options.offsetBefore;\n                var o2 = $scope.vsRepeat.sizesCumulative[$scope.vsRepeat.startIndex + $scope[collectionName].length] + options.offsetBefore;\n                var total = $scope.vsRepeat.totalSize;\n                $beforeContent.css(getLayoutProps(o1 + 'px'));\n                $afterContent.css(getLayoutProps(total - o2 + 'px'));\n              }\n\n              return digestRequired;\n            }\n\n            function _warnMismatch() {\n              $scope.$$postDigest(function () {\n                window.requestAnimationFrame(function () {\n                  var expectedSize = $scope.vsRepeat.sizesCumulative[originalLength];\n                  var compStyle = window.getComputedStyle(repeatContainer[0]);\n                  var paddings = options.horizontal ? ['paddingLeft', 'paddingRight'] : ['paddingTop', 'paddingBottom'];\n                  var containerSize = repeatContainer[0][scrollSize] - paddings.reduce(function (acc, prop) {\n                    return acc + Number(compStyle[prop].slice(0, -2));\n                  }, 0);\n\n                  if (repeatContainer[0][scrollSize] && expectedSize !== containerSize) {\n                    console.warn('vsRepeat: size mismatch. Expected size ' + expectedSize + 'px whereas actual size is ' + containerSize + 'px. Fix vsSize on element:', $element[0]);\n                  }\n                });\n              });\n            }\n          }\n        };\n      }\n    };\n  }]);\n  angular.element(document.head).append(\"<style id=\\\"angular-vs-repeat-style\\\">\\n\\t  \\t.vs-repeat-debug-element {\\n        top: 50%;\\n        left: 0;\\n        right: 0;\\n        height: 1px;\\n        background: red;\\n        z-index: 99999999;\\n        box-shadow: 0 0 20px red;\\n      }\\n\\n      .vs-repeat-debug-element + .vs-repeat-debug-element {\\n        display: none;\\n      }\\n\\n      .vs-repeat-before-content,\\n      .vs-repeat-after-content {\\n        border: none !important;\\n        padding: 0 !important;\\n      }\\n    </style>\");\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = vsRepeatModule.name;\n  }\n})(window, window.angular);"],"sourceRoot":""}