{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fbjs/lib/EventListener.js","webpack:///./node_modules/fbjs/lib/ExecutionEnvironment.js","webpack:///./node_modules/fbjs/lib/camelize.js","webpack:///./node_modules/fbjs/lib/camelizeStyleName.js","webpack:///./node_modules/fbjs/lib/containsNode.js","webpack:///./node_modules/fbjs/lib/emptyFunction.js","webpack:///./node_modules/fbjs/lib/emptyObject.js","webpack:///./node_modules/fbjs/lib/focusNode.js","webpack:///./node_modules/fbjs/lib/getActiveElement.js","webpack:///./node_modules/fbjs/lib/hyphenate.js","webpack:///./node_modules/fbjs/lib/hyphenateStyleName.js","webpack:///./node_modules/fbjs/lib/invariant.js","webpack:///./node_modules/fbjs/lib/isNode.js","webpack:///./node_modules/fbjs/lib/isTextNode.js","webpack:///./node_modules/fbjs/lib/shallowEqual.js","webpack:///./node_modules/fbjs/lib/warning.js","webpack:///./node_modules/object-assign/index.js","webpack:///./node_modules/prop-types/checkPropTypes.js","webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack:///./node_modules/react-dom/cjs/react-dom.development.js","webpack:///./node_modules/react-dom/index.js","webpack:///./node_modules/react/cjs/react.development.js","webpack:///./node_modules/react/index.js","webpack:///./src/maasserver/static/js/angular/3rdparty/ng-tags-input.js","webpack:///./src/maasserver/static/js/angular/3rdparty/sticky.js","webpack:///./src/maasserver/static/js/angular/3rdparty/sticky.min.js","webpack:///./src/maasserver/static/js/angular/3rdparty/vs-repeat.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","emptyFunction","EventListener","listen","target","eventType","callback","addEventListener","remove","removeEventListener","attachEvent","detachEvent","capture","console","error","registerDefault","canUseDOM","window","document","createElement","ExecutionEnvironment","canUseWorkers","Worker","canUseEventListeners","canUseViewport","screen","isInWorker","_hyphenPattern","string","replace","_","character","toUpperCase","camelize","msPattern","isTextNode","containsNode","outerNode","innerNode","parentNode","contains","compareDocumentPosition","makeEmptyFunction","arg","thatReturns","thatReturnsFalse","thatReturnsTrue","thatReturnsNull","thatReturnsThis","this","thatReturnsArgument","emptyObject","freeze","node","focus","e","doc","undefined","activeElement","body","_uppercasePattern","toLowerCase","hyphenate","validateFormat","format","Error","condition","a","b","f","args","argIndex","framesToPop","defaultView","ownerDocument","Node","nodeType","nodeName","isNode","is","x","y","objA","objB","keysA","keys","keysB","length","warning","indexOf","_len2","arguments","Array","_key2","_len","_key","message","apply","concat","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","assign","test1","String","getOwnPropertyNames","test2","fromCharCode","map","join","test3","split","forEach","letter","err","shouldUseNative","source","from","symbols","to","val","TypeError","toObject","key","invariant","ReactPropTypesSecret","loggedTypeFailures","typeSpecs","values","location","componentName","getStack","typeSpecName","ex","stack","React","_assign","getActiveElement","shallowEqual","focusNode","checkPropTypes","hyphenateStyleName","camelizeStyleName","RESERVED_PROPS","children","dangerouslySetInnerHTML","defaultValue","defaultChecked","innerHTML","suppressContentEditableWarning","suppressHydrationWarning","style","checkMask","bitmask","DOMPropertyInjection","MUST_USE_PROPERTY","HAS_BOOLEAN_VALUE","HAS_NUMERIC_VALUE","HAS_POSITIVE_NUMERIC_VALUE","HAS_OVERLOADED_BOOLEAN_VALUE","HAS_STRING_BOOLEAN_VALUE","injectDOMPropertyConfig","domPropertyConfig","Injection","Properties","DOMAttributeNamespaces","DOMAttributeNames","DOMMutationMethods","propName","properties","lowerCased","propConfig","propertyInfo","attributeName","attributeNamespace","propertyName","mutationMethod","mustUseProperty","hasBooleanValue","hasNumericValue","hasPositiveNumericValue","hasOverloadedBooleanValue","hasStringBooleanValue","ATTRIBUTE_NAME_START_CHAR","ATTRIBUTE_NAME_CHAR","ROOT_ATTRIBUTE_NAME","shouldSetAttribute","isReservedProp","shouldAttributeAcceptBooleanValue","getPropertyInfo","prefix","slice","injection","HTMLDOMPropertyConfig","allowFullScreen","async","autoFocus","autoPlay","checked","cols","contentEditable","controls","default","defer","disabled","download","draggable","formNoValidate","hidden","loop","multiple","muted","noValidate","open","playsInline","readOnly","required","reversed","rows","rowSpan","scoped","seamless","selected","size","start","span","spellCheck","tabIndex","itemScope","acceptCharset","className","htmlFor","httpEquiv","removeAttribute","type","hasAttribute","setAttribute","validity","badInput","HAS_STRING_BOOLEAN_VALUE$1","NS","SVGDOMPropertyConfig","autoReverse","externalResourcesRequired","preserveAlpha","xlinkActuate","xlinkArcrole","xlinkHref","xlinkRole","xlinkShow","xlinkTitle","xlinkType","xmlBase","xmlLang","xmlSpace","CAMELIZE","capitalize","token","original","reactName","ReactErrorUtils","_caughtError","_hasCaughtError","_rethrowError","_hasRethrowError","injectErrorUtils","injectedErrorUtils","invokeGuardedCallback","func","context","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","clearCaughtError","rethrowCaughtError","funcArgs","dispatchEvent","createEvent","fakeNode","didError","didSetError","isCrossOriginError","onError","event","colno","lineno","evtType","callCallback","evt","initEvent","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","phasedRegistrationNames","phaseName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","possibleRegistrationNames","ondblclick","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","validateEventDispatches","EventPluginRegistry","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","injection$2","Injected","executeDispatch","simulated","listener","inst","currentTarget","accumulateInto","current","next","isArray","push","forEachAccumulated","arr","cb","scope","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","listenersLen","instancesIsArr","instancesLen","eventQueue","executeDispatchesAndRelease","isPropagationStopped","executeDispatchesInOrder","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","injection$1","getListener","stateNode","props","tag","shouldPreventMouseEvent","topLevelType","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","enqueueEvents","processEventQueue","processingEventQueue","EventPluginHub","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","randomKey","Math","random","toString","internalInstanceKey","internalEventHandlersKey","precacheFiberNode$1","hostInst","getClosestInstanceFromNode","parents","closest","pop","getInstanceFromNode$1","getNodeFromInstance$1","getFiberCurrentPropsFromNode$1","updateFiberProps$1","ReactDOMComponentTree","precacheFiberNode","updateFiberProps","getParent","traverseTwoPhase","fn","path","traverseEnterLeave","argFrom","argTo","common","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","getLowestCommonAncestor","pathFrom","pathTo","_alternate","_i","accumulateDirectionalDispatches","phase","propagationPhase","listenerAtPhase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateEnterLeaveDispatches","leave","enter","EventPropagators","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","contentKey","getTextContentAccessor","documentElement","compositionState","_root","_startText","_fallbackText","getData","end","startValue","startLength","endValue","getText","endLength","minEnd","sliceTail","didWarnForAddedNewProperty","isProxySupported","Proxy","EVENT_POOL_SIZE","shouldBeReleasedProperties","EventInterface","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","SyntheticEvent","preventDefault","stopPropagation","Interface","normalize","returnValue","isDefaultPrevented","getPooledWarningPropertyDefinition","getVal","isFunction","set","warn","action","result","getPooledEvent","nativeInst","eventPool","instance","releasePooledEvent","destructor","addEventPoolingTo","EventConstructor","getPooled","cancelBubble","persist","augmentClass","Class","E","construct","create","that","prop","SyntheticEvent$1","SyntheticCompositionEvent","dispatchMarker","data","SyntheticInputEvent","END_KEYCODES","START_KEYCODE","canUseCompositionEvent","documentMode","opera","canUseTextInputEvent","version","parseInt","useFallbackCompositionData","SPACEBAR_CODE","SPACEBAR_CHAR","beforeInput","bubbled","captured","compositionEnd","compositionStart","compositionUpdate","hasSpaceKeypress","isFallbackCompositionEnd","keyCode","getDataFromCustomEvent","detail","isComposing","extractCompositionEvent","fallbackData","getCompositionEventType","isFallbackCompositionStart","initialize","customData","getFallbackBeforeInputChars","chars","ctrlKey","altKey","metaKey","isKeypressCommand","char","which","extractBeforeInputEvent","getNativeBeforeInputChars","BeforeInputEventPlugin","fiberHostComponent","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","restoreControlledState","injection$3","injectFiberControlledHostComponent","hostComponentImpl","enqueueStateRestore","restoreStateIfNeeded","queuedTargets","ReactControlledComponent","fiberBatchedUpdates","bookkeeping","isNestingBatched","batchedUpdates","injection$4","injectFiberBatchedUpdates","_batchedUpdates","supportedInputTypes","color","date","datetime","datetime-local","email","month","number","password","range","search","tel","text","time","url","week","isTextInputElement","elem","useHasFeature","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","getEventTarget","srcElement","correspondingUseElement","isEventSupported","eventNameSuffix","isSupported","element","implementation","hasFeature","isCheckable","getTracker","_valueTracker","track","valueField","descriptor","getOwnPropertyDescriptor","currentValue","getValue","setValue","stopTracking","detachTracker","trackValueOnNode","updateValueIfChanged","tracker","lastValue","nextValue","getValueFromNode","eventTypes$1","change","createAndAccumulateChangeEvent","activeElementInst","runEventInBatch","getInstIfValueChanged","getTargetInstForChangeEvent","isInputEventSupported","stopWatchingForValueChange","handlePropertyChange","manualDispatchChangeEvent","handleEventsForInputEventPolyfill","startWatchingForValueChange","getTargetInstForInputEventPolyfill","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","ChangeEventPlugin","_isInputEventSupported","getTargetInstFunc","handleEventFunc","targetNode","shouldUseClickEvent","state","_wrapperState","controlled","getAttribute","handleControlledInputBlur","SyntheticUIEvent","view","modifierKeyToProp","Alt","Control","Meta","Shift","modifierStateGetter","keyArg","getModifierState","keyProp","getEventModifierState","MouseEventInterface","screenX","screenY","clientX","clientY","pageX","pageY","shiftKey","button","buttons","relatedTarget","fromElement","toElement","SyntheticMouseEvent","eventTypes$2","mouseEnter","mouseLeave","EnterLeaveEventPlugin","win","parentWindow","related","fromNode","toNode","_reactInternalFiber","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","getComponentName","fiber","displayName","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","Err","Ref","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","effectTag","isFiberMounted","isMounted","component","owner","ownerFiber","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","parentA","parentB","child","sibling","didFindChild","_child","CALLBACK_BOOKKEEPING_POOL_SIZE","callbackBookkeepingPool","findRootContainerNode","containerInfo","handleTopLevelImpl","bookKeeping","ancestor","ancestors","root","_handleTopLevel","_enabled","setHandleTopLevel","handleTopLevel","setEnabled","enabled","isEnabled","trapBubbledEvent","handlerBaseName","bind","trapCapturedEvent","getTopLevelCallbackBookKeeping","ReactDOMEventListener","makePrefixMap","styleProp","prefixes","vendorPrefixes","animationend","animationiteration","animationstart","transitionend","prefixedEventNames","getVendorPrefixedEventName","prefixMap","animation","transition","topLevelTypes","topAbort","topAnimationEnd","topAnimationIteration","topAnimationStart","topBlur","topCancel","topCanPlay","topCanPlayThrough","topChange","topClick","topClose","topCompositionEnd","topCompositionStart","topCompositionUpdate","topContextMenu","topCopy","topCut","topDoubleClick","topDrag","topDragEnd","topDragEnter","topDragExit","topDragLeave","topDragOver","topDragStart","topDrop","topDurationChange","topEmptied","topEncrypted","topEnded","topError","topFocus","topInput","topKeyDown","topKeyPress","topKeyUp","topLoadedData","topLoad","topLoadedMetadata","topLoadStart","topMouseDown","topMouseMove","topMouseOut","topMouseOver","topMouseUp","topPaste","topPause","topPlay","topPlaying","topProgress","topRateChange","topScroll","topSeeked","topSeeking","topSelectionChange","topStalled","topSuspend","topTextInput","topTimeUpdate","topToggle","topTouchCancel","topTouchEnd","topTouchMove","topTouchStart","topTransitionEnd","topVolumeChange","topWaiting","topWheel","alreadyListeningTo","reactTopListenersCounter","topListenersIDKey","getListeningForDocument","mountAt","getLeafNode","firstChild","getSiblingNode","nextSibling","getNodeForCharacterOffset","offset","nodeStart","nodeEnd","textContent","getOffsets","selection","getSelection","rangeCount","anchorNode","anchorOffset","focusNode$$1","focusOffset","indexWithinAnchor","indexWithinFocus","outer","nodeValue","getModernOffsetsFromPoints","hasSelectionCapabilities","getSelectionInformation","focusedElem","selectionRange","input","selectionStart","selectionEnd","getSelection$1","restoreSelection","priorSelectionInformation","curFocusedElem","priorFocusedElem","priorSelectionRange","offsets","min","extend","temp","startMarker","endMarker","createRange","setStart","removeAllRanges","addRange","setEnd","setOffsets","setSelection","left","scrollLeft","top","scrollTop","info","skipSelectionChangeEvent","eventTypes$3","select","activeElement$1","activeElementInst$1","lastSelection","mouseDown","constructSelectEvent","currentSelection","syntheticEvent","SelectEventPlugin","isListening","dependency","isListeningToAllDependencies","SyntheticAnimationEvent","animationName","elapsedTime","pseudoElement","ClipboardEventInterface","clipboardData","SyntheticClipboardEvent","SyntheticFocusEvent","getEventCharCode","charCode","normalizeKey","Esc","Spacebar","Left","Up","Right","Down","Del","Win","Menu","Apps","Scroll","MozPrintableKey","translateToKey","8","9","12","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","45","46","112","113","114","115","116","117","118","119","120","121","122","123","144","145","224","KeyboardEventInterface","repeat","locale","SyntheticKeyboardEvent","SyntheticDragEvent","dataTransfer","TouchEventInterface","touches","targetTouches","changedTouches","SyntheticTouchEvent","SyntheticTransitionEvent","SyntheticWheelEvent","deltaX","wheelDeltaX","deltaY","wheelDeltaY","wheelDelta","deltaZ","deltaMode","eventTypes$4","topLevelEventsToDispatchConfig","capitalizedEvent","onEvent","topEvent","knownHTMLTopLevelTypes","SimpleEventPlugin","runEventQueueInBatch","enableAsyncSubtreeAPI","enableUserTimingAPI","enableMutatingReconciler","enablePersistentReconciler","debugRenderPhaseSideEffects","valueStack","fiberStack","index","createCursor","cursor","describeComponentFrame","ownerName","fileName","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","getCurrentFiberStackAddendum","ReactDebugCurrentFiber","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","getCurrentFiberOwnerName","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","reactEmoji","beginMark","endMark","label","warning$$1","formattedMarkName","formattedLabel","warningEmoji","formatLabel","getFiberMarkName","debugID","getFiberLabel","beginFiberMark","_debugID","has","add","clearFiberMark","clearMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startCommitTimer","clear","stopCommitTimer","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","childContextTypes","popContextProvider","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","NoContext","AsyncUpdates","hasBadMapPolyfill","preventExtensions","debugCounter","createFiber","internalContextTag","ref","pendingProps","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","expirationTime","createWorkInProgress","createFiberFromElement","_owner","Component","isReactComponent","_source","createFiberFromFragment","elements","createFiberFromText","content","createFiberFromCall","handler","createFiberFromReturn","returnNode","createFiberFromPortal","portal","pendingChildren","createFiberRoot","hydrate","uninitializedFiber","remainingExpirationTime","isReadyForCommit","finishedWork","pendingContext","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","onCommitRoot","onCommitUnmount","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","isProcessing","insertUpdateIntoQueue","update","insertUpdateIntoFiber","alternateFiber","queue1","queue2","getStateFromUpdate","prevState","partialState","updateFn","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","_callbackList","commitCallbacks","_callback","fakeInternalInstance","didWarnAboutStateAssignmentForComponent","warnOnInvalidCallback","callerName","ReactFiberClassComponent","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","updater","enqueueSetState","nextCallback","enqueueReplaceState","enqueueForceUpdate","adoptClassInstance","_reactInternalInstance","constructClassInstance","ctor","needsContext","mountClassInstance","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","isPureReactComponent","shouldComponentUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","checkClassInstance","refs","unstable_isAsyncReactComponent","componentWillMount","oldState","callComponentWillMount","componentDidMount","updateClassInstance","resetInputPointers","oldProps","newProps","oldContext","newContext","componentWillReceiveProps","callComponentWillReceiveProps","newState","componentDidUpdate","shouldUpdate","checkShouldComponentUpdate","componentWillUpdate","hasSymbol","Symbol","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","getCurrentFiberStackAddendum$1","didWarnAboutMaps","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","returnFiber","newChild","addendum","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","Map","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","created","existing","updateElement","updateCall","updateReturn","updatePortal","updateFragment","fragment","createChild","$$typeof","_created","_created2","_created3","_created4","_created5","_created6","updateSlot","oldFiber","updateFromMap","newIdx","_matchedFiber","warnOnInvalidKey","knownKeys","isObject","_created7","reconcileSingleElement","reconcileSingleCall","reconcileSingleReturn","reconcileSinglePortal","reconcileSingleTextNode","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","reconcileChildrenArray","newChildrenIterable","iteratorFn","entries","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileChildrenIterator","_isMockFunction","reconcileChildFibers","mountChildFibers","warnedAboutStatelessRefs","ReactFiberBeginWork","config","hostContext","hydrationContext","shouldSetTextContent","useSyncScheduling","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","markRef","finishClassComponent","hasContext","bailoutOnAlreadyFinishedWork","pushHostRootContext","currentChild","cloneChildFibers","bailoutOnLowPriority","nextProps","nextState","beginWork","warningKey","debugSource","mountIndeterminateComponent","updateFunctionalComponent","updateClassComponent","updateHostRoot","prevProps","updateHostComponent","updateHostText","nextCall","updateCallComponent","updatePortalComponent","beginFailedWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","moveCallToHandlerPhase","returns","appendAllReturns","appendAllChildren","parent","updateHostContainer","updatePayload","rootContainerInstance","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","portalOrRoot","container","newChildSet","containerChildSet","appendAllChildrenToContainer","childrenUnchanged","currentInstance","recyclableInstance","newInstance","currentHostContext","completeWork","fiberRoot","_currentHostContext","_instance","_rootContainerInstance","_currentHostContext2","invokeGuardedCallback$2","hasCaughtError$1","clearCaughtError$1","ReactFiberCommitWork","captureError","getPublicInstance","callComponentWillUnmountWithTimer","componentWillUnmount","safelyDetachRef","refError","commitLifeCycles","_updateQueue","_instance2","commitMount","commitAttachRef","commitDetachRef","currentRef","commitUnmount","unmountError","safelyCallComponentWillUnmount","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","isHostParent","currentParentIsValid","currentParent","currentParentIsContainer","findParent","parentFiber","getHostParentFiber","isContainer","before","siblings","getHostSibling","textInstance","NO_CONTEXT","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","parentType","parentProps","parentInstance","_type","_props","_text","tryHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation_1","debugTool","showDialog","capturedError","invokeGuardedCallback$1","didWarnAboutStateTransition","didWarnSetStateChildContext","didWarnStateUpdateForUnmountedComponent","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","ReactFiberScheduler","getChildHostContext","getRootHostContext","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","nextRootInstance","nextRootContext","rootInstance","nextContext","resetHostContainer","ReactFiberHostContext","_ReactFiberBeginWork","_ReactFiberCommitWork","scheduleDeferredCallback","cancelDeferredCallback","prepareForCommit","resetAfterCommit","startTime","mostRecentCurrentTime","expirationContext","isWorking","nextUnitOfWork","nextRoot","nextRenderExpirationTime","capturedErrors","failedBoundaries","commitPhaseBoundaries","firstUncaughtError","didFatal","isUnmounting","interruptedBy","resetContextStack","reset$1","commitAllHostEffects","_current","_current2","commitAllLifeCycles","commitErrorHandling","commitRoot","startCommitHostEffectsTimer","_error","count","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","_didError","_error2","stopCommitLifeCyclesTimer","onCommitWork","scheduleErrorRecovery","_error3","onUncaughtError","remainingTime","resetExpirationTime","renderTime","newExpirationTime","getUpdateExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","performUnitOfWork","onBeginWork","performFailedUnitOfWork","workLoop","shouldYield","hasCapturedError","slowWorkLoopThatChecksForFailedWork","renderRootCatchBlock","failedWork","boundary","unwindContexts","renderRoot","startWorkLoopTimer","uncaughtError","stopWorkLoopTimer","errorBoundaryFound","willRetry","errorBoundaryName","isFailedBoundary","componentDidCatch","_componentStack","_componentName","componentStack","errorBoundary","suppressReactErrorLogging","combinedMessage","logCapturedError","effectfulFiber","computeAsyncExpiration","currentTime","expirationInMs","bucketSizeMs","precision","computeExpirationBucket","recalculateCurrentTime","scheduleWorkImpl","checkRootNeedsClearing","isErrorRecovery","requestWork","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","callbackID","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","timeHeuristicForUnitOfWork","scheduleCallbackWithExpiration","currentMs","expirationMs","expirationTimeToMs","performAsyncWork","timeout","performWorkOnRoot","performWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","dl","minExpirationTime","didExpire","stopRequestCallbackTimer","_error4","_finishedWork","timeRemaining","previousIsBatchingUpdates","unbatchedUpdates","flushSync","previousExpirationContext","syncUpdates","deferredUpdates","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","findCurrentUnmaskedContext","ReactFiberReconciler$1","_ReactFiberScheduler","findHostInstance","hostFiber","findCurrentHostFiber","createContainer","updateContainer","onMountContainer","onUnmountContainer","onUpdateContainer","scheduleTopLevelUpdate","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","findCurrentHostFiberWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","injectInternals","findHostInstanceByFiber","ReactFiberReconciler$2","ReactFiberReconciler$3","reactReconciler","requestAnimationFrame","hasNativePerformanceNow","rIC","cIC","requestIdleCallback","cancelIdleCallback","frameDeadlineObject","scheduledRICCallback","isIdleScheduled","timeoutTime","isAnimationFrameScheduled","frameDeadline","previousFrameTime","activeFrameTime","didTimeout","remaining","messageKey","animationTick","rafTime","nextFrameTime","postMessage","options","frameCallback","setTimeout","Infinity","timeoutID","clearTimeout","lowPriorityWarning$1","VALID_ATTRIBUTE_NAME_REGEX","RegExp","illegalAttributeNameCache","validatedAttributeNameCache","isAttributeNameSafe","test","shouldIgnoreValue","isNaN","getValueForProperty","expected","stringValue","getValueForAttribute","setValueForProperty","deleteValueForProperty","namespace","setAttributeNS","setValueForAttribute","ReactControlledValuePropTypes","hasReadOnlyValue","checkbox","image","radio","reset","submit","onChange","tagName","getCurrentFiberOwnerName$2","getCurrentFiberStackAddendum$3","didWarnValueDefaultValue","didWarnCheckedDefaultChecked","didWarnControlledToUncontrolled","didWarnUncontrolledToControlled","isControlled","getHostProps","max","initialValue","initialChecked","initWrapperState","updateChecked","updateWrapper","valueAsNumber","parseFloat","postMountWrapper","restoreControlledState$1","rootNode","queryRoot","group","querySelectorAll","JSON","stringify","otherNode","form","otherProps","updateNamedCousins","validateProps","getHostProps$1","hostProps","Children","flattenChildren","getCurrentFiberOwnerName$3","getCurrentFiberStackAddendum$4","didWarnValueDefaultValue$1","getDeclarationErrorAddendum","valuePropNames","updateOptions","propValue","setDefaultSelected","selectedValues","selectedValue","defaultSelected","_selectedValue","_i2","getHostProps$2","initWrapperState$1","checkSelectPropTypes","wasMultiple","getCurrentFiberStackAddendum$5","didWarnValDefaultVal","getHostProps$3","initWrapperState$2","updateWrapper$1","newValue","postMountWrapper$3","HTML_NAMESPACE$1","MATH_NAMESPACE","SVG_NAMESPACE","Namespaces","html","mathml","svg","getIntrinsicNamespace","getChildNamespace","parentNamespace","reusableSVGContainer","setInnerHTML","namespaceURI","svgNode","MSApp","execUnsafeLocalFunction","arg0","arg1","arg2","arg3","setTextContent","lastChild","isUnitlessNumber","animationIterationCount","borderImageOutset","borderImageSlice","borderImageWidth","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","columns","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridRowEnd","gridRowSpan","gridRowStart","gridColumn","gridColumnEnd","gridColumnSpan","gridColumnStart","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","floodOpacity","stopOpacity","strokeDasharray","strokeDashoffset","strokeMiterlimit","strokeOpacity","strokeWidth","dangerousStyleValue","isCustomProperty","trim","charAt","substring","prefixKey","badVendoredStyleNamePattern","badStyleValueWithSemicolonPattern","warnedStyleNames","warnedStyleValues","warnedForNaNValue","warnedForInfinityValue","warnValidStyle$1","warnHyphenatedStyleName","warnBadVendoredStyleName","warnStyleValueWithSemicolon","warnStyleValueIsNaN","isFinite","warnStyleValueIsInfinity","createDangerousStringForStyles","styles","serialized","delimiter","styleName","styleValue","setValueForStyles","setProperty","voidElementTags","menuitem","area","base","br","col","embed","hr","img","keygen","link","meta","param","wbr","HTML$1","assertValidProps","isCustomComponent","ariaProperties","aria-current","aria-details","aria-disabled","aria-hidden","aria-invalid","aria-keyshortcuts","aria-label","aria-roledescription","aria-autocomplete","aria-checked","aria-expanded","aria-haspopup","aria-level","aria-modal","aria-multiline","aria-multiselectable","aria-orientation","aria-placeholder","aria-pressed","aria-readonly","aria-required","aria-selected","aria-sort","aria-valuemax","aria-valuemin","aria-valuenow","aria-valuetext","aria-atomic","aria-busy","aria-live","aria-relevant","aria-dropeffect","aria-grabbed","aria-activedescendant","aria-colcount","aria-colindex","aria-colspan","aria-controls","aria-describedby","aria-errormessage","aria-flowto","aria-labelledby","aria-owns","aria-posinset","aria-rowcount","aria-rowindex","aria-rowspan","aria-setsize","warnedProperties","rARIA","rARIACamel","getStackAddendum","validateProperty","ariaName","correctName","standardName","validateProperties","invalidProps","unknownPropString","warnInvalidARIAProps","didWarnValueNull","getStackAddendum$1","possibleStandardNames","accept","acceptcharset","accept-charset","accesskey","allowfullscreen","alt","as","autocapitalize","autocomplete","autocorrect","autofocus","autoplay","autosave","cellpadding","cellspacing","challenge","charset","cite","class","classid","classname","colspan","contenteditable","contextmenu","controlslist","coords","crossorigin","dangerouslysetinnerhtml","defaultchecked","defaultvalue","dir","enctype","for","formmethod","formaction","formenctype","formnovalidate","formtarget","frameborder","headers","height","high","href","hreflang","htmlfor","httpequiv","http-equiv","icon","id","innerhtml","inputmode","integrity","itemid","itemprop","itemref","itemscope","itemtype","keyparams","keytype","kind","lang","list","low","manifest","marginwidth","marginheight","maxlength","media","mediagroup","method","minlength","nonce","novalidate","optimum","pattern","placeholder","playsinline","poster","preload","profile","radiogroup","readonly","referrerpolicy","rel","role","rowspan","sandbox","scrolling","shape","sizes","spellcheck","src","srcdoc","srclang","srcset","summary","tabindex","title","usemap","width","wmode","wrap","about","accentheight","accent-height","accumulate","additive","alignmentbaseline","alignment-baseline","allowreorder","alphabetic","amplitude","arabicform","arabic-form","ascent","attributename","attributetype","autoreverse","azimuth","basefrequency","baselineshift","baseline-shift","baseprofile","bbox","begin","bias","by","calcmode","capheight","cap-height","clip","clippath","clip-path","clippathunits","cliprule","clip-rule","colorinterpolation","color-interpolation","colorinterpolationfilters","color-interpolation-filters","colorprofile","color-profile","colorrendering","color-rendering","contentscripttype","contentstyletype","cx","cy","datatype","decelerate","descent","diffuseconstant","direction","display","divisor","dominantbaseline","dominant-baseline","dur","dx","dy","edgemode","elevation","enablebackground","enable-background","exponent","externalresourcesrequired","fill","fillopacity","fill-opacity","fillrule","fill-rule","filter","filterres","filterunits","floodopacity","flood-opacity","floodcolor","flood-color","focusable","fontfamily","font-family","fontsize","font-size","fontsizeadjust","font-size-adjust","fontstretch","font-stretch","fontstyle","font-style","fontvariant","font-variant","fontweight","font-weight","fx","fy","g1","g2","glyphname","glyph-name","glyphorientationhorizontal","glyph-orientation-horizontal","glyphorientationvertical","glyph-orientation-vertical","glyphref","gradienttransform","gradientunits","hanging","horizadvx","horiz-adv-x","horizoriginx","horiz-origin-x","ideographic","imagerendering","image-rendering","in2","in","inlist","intercept","k1","k2","k3","k4","k","kernelmatrix","kernelunitlength","kerning","keypoints","keysplines","keytimes","lengthadjust","letterspacing","letter-spacing","lightingcolor","lighting-color","limitingconeangle","local","markerend","marker-end","markerheight","markermid","marker-mid","markerstart","marker-start","markerunits","markerwidth","mask","maskcontentunits","maskunits","mathematical","mode","numoctaves","operator","orient","orientation","origin","overflow","overlineposition","overline-position","overlinethickness","overline-thickness","paintorder","paint-order","panose1","panose-1","pathlength","patterncontentunits","patterntransform","patternunits","pointerevents","pointer-events","points","pointsatx","pointsaty","pointsatz","preservealpha","preserveaspectratio","primitiveunits","radius","refx","refy","renderingintent","rendering-intent","repeatcount","repeatdur","requiredextensions","requiredfeatures","resource","restart","results","rotate","rx","ry","scale","security","seed","shaperendering","shape-rendering","slope","spacing","specularconstant","specularexponent","speed","spreadmethod","startoffset","stddeviation","stemh","stemv","stitchtiles","stopcolor","stop-color","stopopacity","stop-opacity","strikethroughposition","strikethrough-position","strikethroughthickness","strikethrough-thickness","stroke","strokedasharray","stroke-dasharray","strokedashoffset","stroke-dashoffset","strokelinecap","stroke-linecap","strokelinejoin","stroke-linejoin","strokemiterlimit","stroke-miterlimit","strokewidth","stroke-width","strokeopacity","stroke-opacity","suppresscontenteditablewarning","suppresshydrationwarning","surfacescale","systemlanguage","tablevalues","targetx","targety","textanchor","text-anchor","textdecoration","text-decoration","textlength","textrendering","text-rendering","transform","typeof","u1","u2","underlineposition","underline-position","underlinethickness","underline-thickness","unicode","unicodebidi","unicode-bidi","unicoderange","unicode-range","unitsperem","units-per-em","unselectable","valphabetic","v-alphabetic","vectoreffect","vector-effect","vertadvy","vert-adv-y","vertoriginx","vert-origin-x","vertoriginy","vert-origin-y","vhanging","v-hanging","videographic","v-ideographic","viewbox","viewtarget","visibility","vmathematical","v-mathematical","vocab","widths","wordspacing","word-spacing","writingmode","writing-mode","x1","x2","xchannelselector","xheight","x-height","xlinkactuate","xlink:actuate","xlinkarcrole","xlink:arcrole","xlinkhref","xlink:href","xlinkrole","xlink:role","xlinkshow","xlink:show","xlinktitle","xlink:title","xlinktype","xlink:type","xmlbase","xml:base","xmllang","xml:lang","xmlns","xml:space","xmlnsxlink","xmlns:xlink","xmlspace","y1","y2","ychannelselector","z","zoomandpan","getStackAddendum$2","warnedProperties$1","hasOwnProperty$1","EVENT_NAME_REGEX","INVALID_EVENT_NAME_REGEX","rARIA$1","rARIACamel$1","validateProperty$1","canUseEventSystem","isReserved","warnUnknownProperties","unknownProps","getCurrentFiberOwnerName$1","getCurrentFiberStackAddendum$2","didWarnInvalidHydration","didWarnShadyDOM","DANGEROUSLY_SET_INNER_HTML","SUPPRESS_CONTENT_EDITABLE_WARNING","SUPPRESS_HYDRATION_WARNING$1","AUTOFOCUS","CHILDREN","STYLE","HTML","HTML_NAMESPACE","warnedUnknownTags","dialog","validatePropertiesInDevelopment","validateProperties$1","validateProperties$2","NORMALIZE_NEWLINES_REGEX","NORMALIZE_NULL_AND_REPLACEMENT_REGEX","normalizeMarkupForTextOrAttribute","markup","warnForTextDifference","serverText","clientText","normalizedClientText","normalizedServerText","warnForPropDifference","serverValue","clientValue","normalizedClientValue","normalizedServerValue","warnForExtraAttributes","attributeNames","names","warnForInvalidEventListener","normalizeHTML","testElement","createElementNS","ensureListeningTo","rootContainerElement","contentDocumentHandle","listenTo","getOwnerDocumentFromRootContainer","mediaEvents","trapClickOnNonInteractiveElement","onclick","createElement$1","domElement","isCustomComponentTag","div","createTextNode$1","createTextNode","setInitialProperties$1","rawProps","shadyRoot","propKey","nextProp","nextHtml","setInitialDOMProperties","postMountWrapper$1","postMountWrapper$2","onClick","diffProperties$1","lastRawProps","nextRawProps","lastProps","styleUpdates","lastStyle","lastProp","lastHtml","updateProperties$1","wasCustomComponentTag","updateDOMProperties","postUpdateWrapper","diffHydratedProperties$1","extraAttributeNames","attributes","rawHtml","serverHTML","expectedHTML","expectedStyle","ownNamespace","diffHydratedText$1","textNode","warnForUnmatchedText$1","warnForDeletedHydratableElement$1","warnForDeletedHydratableText$1","warnForInsertedHydratedElement$1","warnForInsertedHydratedText$1","validateDOMNesting","ReactDOMFiberComponent","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","warnForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","restoreControlledState$3","restoreControlledState$2","getCurrentFiberStackAddendum$6","specialTags","inScopeTags","buttonScopeTags","impliedEndTags","emptyAncestorInfo","formTag","aTagInScope","buttonTagInScope","nobrTagInScope","pTagInButtonScope","listItemTagAutoclosing","dlItemTagAutoclosing","isTagValidWithParent","parentTag","findInvalidAncestorForTag","ancestorInfo","didWarn","childTag","childText","parentInfo","invalidParent","invalidAncestor","invalidParentOrAncestor","ancestorTag","warnKey","tagDisplayName","whitespaceInfo","updatedAncestorInfo","oldInfo","isTagValidInContext","validateDOMNesting$1","eventsEnabled","selectionInformation","isValidContainer","getReactRootElementInContainer","DOMRenderer","validatedTag","parentHostContext","parentHostContextDev","internalInstanceHandle","hostContextDev","ownAncestorInfo","shouldAutoFocusHostComponent","__html","beforeChild","warnedAboutHydrateAPI","renderSubtreeIntoContainer","forceHydrate","_reactRootContainer","hostInstance","isRootRenderedBySomeReact","rootEl","hasNonRootReactChild","shouldHydrate","rootElement","shouldHydrateDueToLegacyHeuristic","warned","rootSibling","newRoot","createPortal","createPortal$1","ReactRoot","unmount","ReactDOM","findDOMNode","componentOrElement","warnedAboutRefsInRender","unstable_renderSubtreeIntoContainer","containerNode","unmountComponentAtNode","renderedByDifferentReact","_rootEl","isContainerReactRoot","unstable_createPortal","unstable_batchedUpdates","unstable_deferredUpdates","bundleType","rendererPackageName","self","navigator","userAgent","protocol","ReactDOM$2","ReactDOM$3","reactDom","warnNoop","publicInstance","ReactNoopUpdateQueue","completeState","setState","forceUpdate","deprecatedAPIs","replaceState","defineDeprecationWarning","methodName","fnName","PureComponent","ComponentDummy","pureComponentPrototype","AsyncComponent","asyncComponentPrototype","specialPropKeyWarningShown","specialPropRefWarningShown","__self","__source","hasValidRef","isReactWarning","hasValidKey","ReactElement","writable","childrenLength","childArray","warnAboutAccessingKey","defineKeyPropWarningGetter","warnAboutAccessingRef","defineRefPropWarningGetter","isValidElement","impl","SEPARATOR","SUBSEPARATOR","userProvidedKeyEscapeRegex","escapeUserProvidedKey","POOL_SIZE","traverseContextPool","getPooledTraverseContext","mapResult","keyPrefix","mapFunction","mapContext","traverseContext","releaseTraverseContext","traverseAllChildren","traverseAllChildrenImpl","nameSoFar","invokeCallback","getComponentKey","subtreeCount","nextNamePrefix","ii","childrenString","escaperLookup","=",":","match","forEachSingleChild","mapSingleChildIntoContext","childKey","oldElement","newKey","mappedChild","mapIntoWithKeyPrefixInternal","_self","array","escapedPrefix","currentlyValidatingElement","propTypesMisspellWarningShown","VALID_FRAGMENT_PROPS","validateExplicitKey","parentName","getCurrentComponentErrorInfo","childOwner","validateChildKeys","validatePropTypes","componentClass","PropTypes","createElementWithValidation","validType","sourceInfo","elementProps","getSourceInfoErrorAddendum","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","validateFragmentProps","forEachFunc","forEachContext","toArray","only","unstable_AsyncComponent","cloneElement","newElement","createFactory","validatedFactory","ReactComponentTreeHook","React$2","React$3","react","KEYS","SUPPORTED_INPUT_TYPES","tagsInput","angular","directive","$timeout","$document","$window","tagsInputConfig","tiUtil","validateType","restrict","require","tags","onTagAdding","onTagAdded","onInvalidTag","onTagRemoving","onTagRemoved","transclude","templateUrl","controller","$scope","$attrs","$element","simplePubSub","load","template","Number","removeTagSymbol","replaceSpacesWithDashes","Boolean","minLength","maxLength","addOnEnter","addOnSpace","addOnComma","addOnBlur","addOnPaste","pasteSplitPattern","allowedTagsPattern","enableEditingLastTag","minTags","maxTags","displayProperty","keyProperty","allowLeftoverText","addFromAutocompleteOnly","tagList","getTagText","setTagText","tagIsValid","safeToString","tagText","findInObjectArray","items","$tag","addText","trigger","splice","clearSelection","selectPrior","selectNext","removeSelected","handleUndefinedResult","registerAutocomplete","find","addTag","focusInput","getTags","getCurrentTagText","newTag","getOptions","on","registerTagItem","removeTag","attrs","ngModelCtrl","setElementValidity","hotkeys","validationOptions","$setValidity","hasFocus","$isEmpty","invalid","setText","$watch","makeObjectArray","$observe","eventHandlers","keydown","$event","blur","lostFocusToBrowserWindow","lostFocusToChildElement","paste","getTextData","originalEvent","host","click","$setViewValue","triggerHandler","shouldAdd","shouldRemove","shouldSelect","shouldEditLastTag","addKeys","tagsInputCtrl","$$template","$$removeTagSymbol","$getDisplayText","$removeTag","$index","$sce","$q","debounceDelay","highlightMatchedText","maxResultsToShow","loadOnDownArrow","loadOnEmpty","loadOnFocus","selectFirstMatch","suggestionList","loadFn","getDifference","lastPromise","getTagId","array1","array2","item","defaultComparer","visible","query","show","debounce","promise","when","$query","then","registerAutocompleteMatch","getQuery","shouldLoadSuggestions","addSuggestionByIndex","addSuggestion","added","copy","handled","stopImmediatePropagation","eq","elementTop","elementHeight","parentHeight","parentScrollTop","scrollToElement","autoCompleteCtrl","autoComplete","$parent","$highlight","safeHighlight","trustAsHtml","ctrl","transcludeFn","append","resize","threshold","getTextAutosizeThreshold","css","originalValue","isString","$parsers","unshift","$formatters","$modelValue","tiBindAttrs","$set","provider","globalDefaults","interpolationStatus","autosizeThreshold","setDefaults","defaults","setActiveInterpolation","setTextAutosizeThreshold","$get","$interpolate","converters","defaultValidator","localDefault","validator","converter","getDefault","updateValue","globalValue","isDefined","factory","delay","timeoutId","cancel","obj","comparer","some","str","encodeHTML","expression","escapeRegexChars","isUndefined","valueIfUndefined","every","run","$templateCache","put","$elem","onStickyHeighUnbind","originalInitialCSS","originalOffset","stickyLine","initialCSS","scrollableNodeTagName","initialPosition","initialStyle","attr","stickyBottomLine","isSticking","stickyClass","unstickyClass","bodyClass","bottomClass","scrollbar","findAncestorTag","windowElement","scrollbarElement","$body","$onResize","$root","$$phase","$apply","onResize","usePlaceholder","anchor","confine","isStickyLayoutDeferred","isStickyLayoutWatched","shouldInitialize","initSticky","checkIfShouldStick","getInitialDimensions","getBoundingClientRect","oldValue","onDigest","$on","onDestroy","mediaQuery","matchMedia","matches","unStickElement","shouldStick","scrollbarPosition","scrollbarYPos","closestLine","topDistance","abs","bottomDistance","getClosest","stickLimit","innerHeight","offsetHeight","elementsOffsetFromTop","offsetWidth","addClass","removeClass","createPlaceholder","fromDirection","position","cssLeft","marginTop","marginBottom","off","offsetFromTop","HTMLElement","getComputedStyle","getPropertyValue","scrollbarHeight","newVal","oldVal","elemIsShowed","elemWasHidden","valChange","notSticking","isBottomedOut","updateStickyContentUpdateDimensions","elementsDistanceFromTop","parentsDistanceFromTop","scrollbarDistanceFromTop","computedStyle","currentStyle","borderTopWidth","borderBottomWidth","after","pageYOffset","getElement","getScrollbar","getInitialCSS","getAnchor","getOriginalInitialCSS","processUnStickElement","processCheckIfShouldStick","$el","el","computed","prevDisplay","resetLayout","newWidth","newHeight","e_bcr","scrollTo","dde","matchingFunction","matchesSelector","webkitMatches","webkitMatchesSelector","msMatches","msMatchesSelector","mozMatches","mozMatchesSelector","closestElement","selector","getWindowScroll","pageXOffset","sx","getClientSize","sizeProp","innerWidth","vsRepeatModule","$compile","$parse","compile","ngRepeatExpression","expressionMatches","lhs","rhs","rhsSuffix","originalNgRepeatAttr","repeatContainer","vsRepeatContainer","querySelector","ngRepeatChild","childCloneHtml","outerHTML","collectionName","isNgRepeatStart","attributesDictionary","vsRepeat","vsOffsetBefore","vsOffsetAfter","vsScrolledToEndOffset","vsScrolledToBeginningOffset","vsExcess","exec","repeaterElement","empty","pre","originalLength","_prevStartIndex","_prevEndIndex","_minStartIndex","_maxEndIndex","_prevClientSize","childClone","childTagName","originalCollection","$$horizontal","vsHorizontal","$beforeContent","$afterContent","autoSize","sizesPropertyExists","vsSize","vsSizeProperty","$scrollParent","vsScrollParent","$$options","$eval","vsOptions","clientSize","offsetSize","scrollPos","totalSize","refresh","sizesCumulative","$new","elementSize","$destroy","sum","res","setAutoSize","reinitialize","$$postDigest","gotSomething","insideStartEndSequence","dereg","getLayoutProp","layoutPropPrefix","scrollHandler","updateInnerCollection","$digest","onWindowResize","vsAutoresize","offsetBefore","offsetAfter","$emit","startIndex","endIndex","reinitOnClientHeightChange","ch","scrollProp","vsElement","scrollElement","isHorizontal","$scrollPosition","$clientSize","scrollOffset","__startIndex","__endIndex","floor","excess","ceil","latch","digestRequired","hunked","triggerIndex","vsScrolledToEnd","scrolledToEndOffset","vsScrolledToBeginning","scrolledToBeginningOffset","parsed","o1","o2","total","$watchCollection","coll"],"mappings":"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C,KAAA,OACAC,GAAA,KACAC,UAAA,YACAC,UAAA,YACAC,UAAA,YACA95D,GAAA,KACA+5D,OAAA,SACAC,SAAA,WACAC,QAAA,UACAC,UAAA,YACAC,SAAA,WACAC,UAAA,YACAC,QAAA,UACAC,KAAA,OACA/+B,MAAA,QACAg/B,KAAA,OACAC,KAAA,OACAtyD,KAAA,OACAuyD,IAAA,MACAC,SAAA,WACAC,YAAA,cACAC,aAAA,eACA9R,IAAA,MACA+R,UAAA,YACAC,MAAA,QACAC,WAAA,aACAC,OAAA,SACAhqC,IAAA,MACAiqC,UAAA,YACA9yD,SAAA,WACAC,MAAA,QACApO,KAAA,OACAkhE,MAAA,QACAC,WAAA,aACA7yD,KAAA,OACA8yD,QAAA,UACAC,QAAA,UACAC,YAAA,cACAC,YAAA,cACAC,OAAA,SACAC,QAAA,UACAC,QAAA,UACAC,WAAA,aACAC,SAAA,WACAC,eAAA,iBACAC,IAAA,MACArzD,SAAA,WACAC,SAAA,WACAqzD,KAAA,OACApzD,KAAA,OACAqzD,QAAA,UACAC,QAAA,UACA9rD,MAAA,QACAtH,OAAA,SACAqzD,UAAA,YACApzD,SAAA,WACAC,SAAA,WACAozD,MAAA,QACAnzD,KAAA,OACAozD,MAAA,QACAlzD,KAAA,OACAmzD,WAAA,aACAC,IAAA,MACAC,OAAA,SACAC,QAAA,UACAC,OAAA,SACAxzD,MAAA,QACAolC,KAAA,OACA7pC,MAAA,QACAk4D,QAAA,UACAC,SAAA,WACAthE,OAAA,SACAuhE,MAAA,QACAjzD,KAAA,OACAkzD,OAAA,SACApiE,MAAA,QACAqiE,MAAA,QACAC,MAAA,QACAC,KAAA,OAGAC,MAAA,QACAC,aAAA,eACAC,gBAAA,eACAC,WAAA,aACAC,SAAA,WACAC,kBAAA,oBACAC,qBAAA,oBACAC,aAAA,eACAC,WAAA,aACAC,UAAA,YACAC,WAAA,aACAC,cAAA,aACAC,OAAA,SACAC,cAAA,gBACAC,cAAA,gBACAC,YAAA,cACAC,QAAA,UACAC,cAAA,gBACAC,cAAA,gBACAC,iBAAA,gBACAC,YAAA,cACAC,KAAA,OACAC,MAA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","file":"vendor-min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar emptyFunction = require('./emptyFunction');\n\n/**\n * Upstream version of event listener. Does not take into account specific\n * nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function listen(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function remove() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  },\n\n  /**\n   * Listen to DOM events during the capture phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  capture: function capture(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, true);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, true);\n        }\n      };\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');\n      }\n      return {\n        remove: emptyFunction\n      };\n    }\n  },\n\n  registerDefault: function registerDefault() {}\n};\n\nmodule.exports = EventListener;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n'use strict';\n\nvar camelize = require('./camelize');\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = require('./isTextNode');\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar emptyObject = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\n\nfunction focusNode(node) {\n  // IE8 can throw \"Can't move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch (e) {}\n}\n\nmodule.exports = focusNode;","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n'use strict';\n\nvar hyphenate = require('./hyphenate');\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;","'use strict';\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = require('./isNode');\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar emptyFunction = require('./emptyFunction');\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== 'production') {\n  var invariant = require('fbjs/lib/invariant');\n  var warning = require('fbjs/lib/warning');\n  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","/** @license React v16.2.0\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = require('react');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar _assign = require('object-assign');\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar EventListener = require('fbjs/lib/EventListener');\nvar getActiveElement = require('fbjs/lib/getActiveElement');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\nvar containsNode = require('fbjs/lib/containsNode');\nvar focusNode = require('fbjs/lib/focusNode');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar checkPropTypes = require('prop-types/checkPropTypes');\nvar hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');\nvar camelizeStyleName = require('fbjs/lib/camelizeStyleName');\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\n// These attributes should be all lowercase to allow for\n// case insensitive checks\nvar RESERVED_PROPS = {\n  children: true,\n  dangerouslySetInnerHTML: true,\n  defaultValue: true,\n  defaultChecked: true,\n  innerHTML: true,\n  suppressContentEditableWarning: true,\n  suppressHydrationWarning: true,\n  style: true\n};\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_PROPERTY: 0x1,\n  HAS_BOOLEAN_VALUE: 0x4,\n  HAS_NUMERIC_VALUE: 0x8,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,\n  HAS_STRING_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n   * attribute namespace URL. (Attribute names not specified use no namespace.)\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function (domPropertyConfig) {\n    var Injection = DOMPropertyInjection;\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    for (var propName in Properties) {\n      !!properties.hasOwnProperty(propName) ? invariant(false, \"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.\", propName) : void 0;\n\n      var lowerCased = propName.toLowerCase();\n      var propConfig = Properties[propName];\n\n      var propertyInfo = {\n        attributeName: lowerCased,\n        attributeNamespace: null,\n        propertyName: propName,\n        mutationMethod: null,\n\n        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),\n        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)\n      };\n      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, \"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s\", propName) : void 0;\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n\n        propertyInfo.attributeName = attributeName;\n      }\n\n      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n      }\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        propertyInfo.mutationMethod = DOMMutationMethods[propName];\n      }\n\n      // Downcase references to whitelist properties to check for membership\n      // without case-sensitivity. This allows the whitelist to pick up\n      // `allowfullscreen`, which should be written using the property configuration\n      // for `allowFullscreen`\n      properties[propName] = propertyInfo;\n    }\n  }\n};\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\n\n/**\n * Map from property \"standard name\" to an object with info about how to set\n * the property in the DOM. Each object contains:\n *\n * attributeName:\n *   Used when rendering markup or with `*Attribute()`.\n * attributeNamespace\n * propertyName:\n *   Used on DOM node instances. (This includes properties that mutate due to\n *   external factors.)\n * mutationMethod:\n *   If non-null, used instead of the property or `setAttribute()` after\n *   initial render.\n * mustUseProperty:\n *   Whether the property must be accessed and mutated as an object property.\n * hasBooleanValue:\n *   Whether the property should be removed when set to a falsey value.\n * hasNumericValue:\n *   Whether the property must be numeric or parse as a numeric and should be\n *   removed when set to a falsey value.\n * hasPositiveNumericValue:\n *   Whether the property must be positive numeric or parse as a positive\n *   numeric and should be removed when set to a falsey value.\n * hasOverloadedBooleanValue:\n *   Whether the property can be used as a flag as well as with a value.\n *   Removed when strictly equal to false; present without a value when\n *   strictly equal to true; present with a value otherwise.\n */\nvar properties = {};\n\n/**\n * Checks whether a property name is a writeable attribute.\n * @method\n */\nfunction shouldSetAttribute(name, value) {\n  if (isReservedProp(name)) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return false;\n  }\n  if (value === null) {\n    return true;\n  }\n  switch (typeof value) {\n    case 'boolean':\n      return shouldAttributeAcceptBooleanValue(name);\n    case 'undefined':\n    case 'number':\n    case 'string':\n    case 'object':\n      return true;\n    default:\n      // function, symbol\n      return false;\n  }\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction shouldAttributeAcceptBooleanValue(name) {\n  if (isReservedProp(name)) {\n    return true;\n  }\n  var propertyInfo = getPropertyInfo(name);\n  if (propertyInfo) {\n    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;\n  }\n  var prefix = name.toLowerCase().slice(0, 5);\n  return prefix === 'data-' || prefix === 'aria-';\n}\n\n/**\n * Checks to see if a property name is within the list of properties\n * reserved for internal React operations. These properties should\n * not be set on an HTML element.\n *\n * @private\n * @param {string} name\n * @return {boolean} If the name is within reserved props\n */\nfunction isReservedProp(name) {\n  return RESERVED_PROPS.hasOwnProperty(name);\n}\n\nvar injection = DOMPropertyInjection;\n\nvar MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;\nvar HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;\nvar HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;\n\nvar HTMLDOMPropertyConfig = {\n  // When adding attributes to this list, be sure to also add them to\n  // the `possibleStandardNames` module to ensure casing and incorrect\n  // name warnings.\n  Properties: {\n    allowFullScreen: HAS_BOOLEAN_VALUE,\n    // specifies target context for links with `preload` type\n    async: HAS_BOOLEAN_VALUE,\n    // Note: there is a special case that prevents it from being written to the DOM\n    // on the client side because the browsers are inconsistent. Instead we call focus().\n    autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    capture: HAS_OVERLOADED_BOOLEAN_VALUE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    cols: HAS_POSITIVE_NUMERIC_VALUE,\n    contentEditable: HAS_STRING_BOOLEAN_VALUE,\n    controls: HAS_BOOLEAN_VALUE,\n    'default': HAS_BOOLEAN_VALUE,\n    defer: HAS_BOOLEAN_VALUE,\n    disabled: HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: HAS_STRING_BOOLEAN_VALUE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    hidden: HAS_BOOLEAN_VALUE,\n    loop: HAS_BOOLEAN_VALUE,\n    // Caution; `option.selected` is not updated if `select.multiple` is\n    // disabled with `removeAttribute`.\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: HAS_BOOLEAN_VALUE,\n    playsInline: HAS_BOOLEAN_VALUE,\n    readOnly: HAS_BOOLEAN_VALUE,\n    required: HAS_BOOLEAN_VALUE,\n    reversed: HAS_BOOLEAN_VALUE,\n    rows: HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: HAS_NUMERIC_VALUE,\n    scoped: HAS_BOOLEAN_VALUE,\n    seamless: HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    size: HAS_POSITIVE_NUMERIC_VALUE,\n    start: HAS_NUMERIC_VALUE,\n    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: HAS_STRING_BOOLEAN_VALUE,\n    // Style must be explicitly set in the attribute list. React components\n    // expect a style object\n    style: 0,\n    // Keep it in the whitelist because it is case-sensitive for SVG.\n    tabIndex: 0,\n    // itemScope is for for Microdata support.\n    // See http://schema.org/docs/gs.html\n    itemScope: HAS_BOOLEAN_VALUE,\n    // These attributes must stay in the white-list because they have\n    // different attribute names (see DOMAttributeNames below)\n    acceptCharset: 0,\n    className: 0,\n    htmlFor: 0,\n    httpEquiv: 0,\n    // Attributes with mutation methods must be specified in the whitelist\n    // Set the string boolean flag to allow the behavior\n    value: HAS_STRING_BOOLEAN_VALUE\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMMutationMethods: {\n    value: function (node, value) {\n      if (value == null) {\n        return node.removeAttribute('value');\n      }\n\n      // Number inputs get special treatment due to some edge cases in\n      // Chrome. Let everything else assign the value attribute as normal.\n      // https://github.com/facebook/react/issues/7253#issuecomment-236074326\n      if (node.type !== 'number' || node.hasAttribute('value') === false) {\n        node.setAttribute('value', '' + value);\n      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {\n        // Don't assign an attribute if validation reports bad\n        // input. Chrome will clear the value. Additionally, don't\n        // operate on inputs that have focus, otherwise Chrome might\n        // strip off trailing decimal places and cause the user's\n        // cursor position to jump to the beginning of the input.\n        //\n        // In ReactDOMInput, we have an onBlur event that will trigger\n        // this function again when focus is lost.\n        node.setAttribute('value', '' + value);\n      }\n    }\n  }\n};\n\nvar HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;\n\n\nvar NS = {\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\n\n/**\n * This is a list of all SVG attributes that need special casing,\n * namespacing, or boolean value assignment.\n *\n * When adding attributes to this list, be sure to also add them to\n * the `possibleStandardNames` module to ensure casing and incorrect\n * name warnings.\n *\n * SVG Attributes List:\n * https://www.w3.org/TR/SVG/attindex.html\n * SMIL Spec:\n * https://www.w3.org/TR/smil\n */\nvar ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,\n    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,\n    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1\n  },\n  DOMAttributeNames: {\n    autoReverse: 'autoReverse',\n    externalResourcesRequired: 'externalResourcesRequired',\n    preserveAlpha: 'preserveAlpha'\n  },\n  DOMAttributeNamespaces: {\n    xlinkActuate: NS.xlink,\n    xlinkArcrole: NS.xlink,\n    xlinkHref: NS.xlink,\n    xlinkRole: NS.xlink,\n    xlinkShow: NS.xlink,\n    xlinkTitle: NS.xlink,\n    xlinkType: NS.xlink,\n    xmlBase: NS.xml,\n    xmlLang: NS.xml,\n    xmlSpace: NS.xml\n  }\n};\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\nATTRS.forEach(function (original) {\n  var reactName = original.replace(CAMELIZE, capitalize);\n\n  SVGDOMPropertyConfig.Properties[reactName] = 0;\n  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;\n});\n\ninjection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\ninjection.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function (injectedErrorUtils) {\n      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar EventPluginRegistry = Object.freeze({\n\tplugins: plugins,\n\teventNameDispatchConfigs: eventNameDispatchConfigs,\n\tregistrationNameModules: registrationNameModules,\n\tregistrationNameDependencies: registrationNameDependencies,\n\tpossibleRegistrationNames: possibleRegistrationNames,\n\tinjectEventPluginOrder: injectEventPluginOrder,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$2 = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n    }\n  }\n};\n\n\n\n\n\n\nvar validateEventDispatches;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection$1 = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\n/**\n * Enqueues a synthetic event that should be dispatched when\n * `processEventQueue` is invoked.\n *\n * @param {*} events An accumulation of synthetic events.\n * @internal\n */\nfunction enqueueEvents(events) {\n  if (events) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n}\n\n/**\n * Dispatches all synthetic events on the event queue.\n *\n * @internal\n */\nfunction processEventQueue(simulated) {\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nvar EventPluginHub = Object.freeze({\n\tinjection: injection$1,\n\tgetListener: getListener,\n\textractEvents: extractEvents,\n\tenqueueEvents: enqueueEvents,\n\tprocessEventQueue: processEventQueue\n});\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode$1(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  // Walk up the tree until we find an ancestor whose instance we have cached.\n  var parents = [];\n  while (!node[internalInstanceKey]) {\n    parents.push(node);\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var closest = void 0;\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {\n    closest = inst;\n  }\n\n  return closest;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps$1(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = Object.freeze({\n\tprecacheFiberNode: precacheFiberNode$1,\n\tgetClosestInstanceFromNode: getClosestInstanceFromNode,\n\tgetInstanceFromNode: getInstanceFromNode$1,\n\tgetNodeFromInstance: getNodeFromInstance$1,\n\tgetFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n\tupdateFiberProps: updateFiberProps$1\n});\n\nfunction getParent(inst) {\n  do {\n    inst = inst['return'];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning(inst, 'Dispatching inst must not be null');\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EventPropagators = Object.freeze({\n\taccumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n\taccumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n\taccumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n\taccumulateDirectDispatches: accumulateDirectDispatches\n});\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nfunction initialize(nativeEventTarget) {\n  compositionState._root = nativeEventTarget;\n  compositionState._startText = getText();\n  return true;\n}\n\nfunction reset() {\n  compositionState._root = null;\n  compositionState._startText = null;\n  compositionState._fallbackText = null;\n}\n\nfunction getData() {\n  if (compositionState._fallbackText) {\n    return compositionState._fallbackText;\n  }\n\n  var start;\n  var startValue = compositionState._startText;\n  var startLength = startValue.length;\n  var end;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  compositionState._fallbackText = endValue.slice(start, sliceTail);\n  return compositionState._fallbackText;\n}\n\nfunction getText() {\n  if ('value' in compositionState._root) {\n    return compositionState._root.value;\n  }\n  return compositionState._root[getTextContentAccessor()];\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar isProxySupported = typeof Proxy === 'function';\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function (Class, Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n  addEventPoolingTo(Class);\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              warning(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case 'topCompositionStart':\n      return eventTypes.compositionStart;\n    case 'topCompositionEnd':\n      return eventTypes.compositionEnd;\n    case 'topCompositionUpdate':\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topKeyUp':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'topKeyDown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'topKeyPress':\n    case 'topMouseDown':\n    case 'topBlur':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType;\n  var fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topCompositionEnd':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'topKeyPress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'topTextInput':\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case 'topPaste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'topKeyPress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'topCompositionEnd':\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n}\n\nvar injection$3 = ReactControlledComponentInjection;\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\nvar ReactControlledComponent = Object.freeze({\n\tinjection: injection$3,\n\tenqueueStateRestore: enqueueStateRestore,\n\trestoreStateIfNeeded: restoreStateIfNeeded\n});\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar fiberBatchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nvar isNestingBatched = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isNestingBatched) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state. Therefore, we add the target to\n    // a queue of work.\n    return fiberBatchedUpdates(fn, bookkeeping);\n  }\n  isNestingBatched = true;\n  try {\n    return fiberBatchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isNestingBatched = false;\n    restoreStateIfNeeded();\n  }\n}\n\nvar ReactGenericBatchingInjection = {\n  injectFiberBatchedUpdates: function (_batchedUpdates) {\n    fiberBatchedUpdates = _batchedUpdates;\n  }\n};\n\nvar injection$4 = ReactGenericBatchingInjection;\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature = document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable,\n    configurable: true,\n    get: function () {\n      return descriptor.get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      descriptor.set.call(this, value);\n    }\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  enqueueEvents(event);\n  processEventQueue(false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: null,\n  detail: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from;\n    var to;\n    if (topLevelType === 'topMouseOut') {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\n// Don't change these two values:\nvar NoEffect = 0; //           0b00000000\nvar PerformedWork = 1; //      0b00000001\n\n// You can change the rest (and add more).\nvar Placement = 2; //          0b00000010\nvar Update = 4; //             0b00000100\nvar PlacementAndUpdate = 6; // 0b00000110\nvar Deletion = 8; //           0b00001000\nvar ContentReset = 16; //      0b00010000\nvar Callback = 32; //          0b00100000\nvar Err = 64; //               0b01000000\nvar Ref = 128; //              0b10000000\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst['return']) {\n    inst = inst['return'];\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\nvar _handleTopLevel = void 0;\n\nfunction setHandleTopLevel(handleTopLevel) {\n  _handleTopLevel = handleTopLevel;\n}\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevelImpl, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nvar ReactDOMEventListener = Object.freeze({\n\tget _enabled () { return _enabled; },\n\tget _handleTopLevel () { return _handleTopLevel; },\n\tsetHandleTopLevel: setHandleTopLevel,\n\tsetEnabled: setEnabled,\n\tisEnabled: isEnabled,\n\ttrapBubbledEvent: trapBubbledEvent,\n\ttrapCapturedEvent: trapCapturedEvent,\n\tdispatchEvent: dispatchEvent\n});\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return '';\n}\n\n/**\n * Types of raw signals from the browser caught at the top level.\n *\n * For events like 'submit' which don't consistently bubble (which we\n * trap at a lower node than `document`), binding at `document` would\n * cause duplicate events so we don't include them here.\n */\nvar topLevelTypes$1 = {\n  topAbort: 'abort',\n  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',\n  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',\n  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',\n  topBlur: 'blur',\n  topCancel: 'cancel',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topChange: 'change',\n  topClick: 'click',\n  topClose: 'close',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoadedData: 'loadeddata',\n  topLoad: 'load',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topScroll: 'scroll',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topSelectionChange: 'selectionchange',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTextInput: 'textInput',\n  topTimeUpdate: 'timeupdate',\n  topToggle: 'toggle',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting',\n  topWheel: 'wheel'\n};\n\nvar BrowserEventConstants = {\n  topLevelTypes: topLevelTypes$1\n};\n\nfunction runEventQueueInBatch(events) {\n  enqueueEvents(events);\n  processEventQueue(false);\n}\n\n/**\n * Streams a fired top-level event to `EventPluginHub` where plugins have the\n * opportunity to create `ReactEvent`s to be dispatched.\n */\nfunction handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventQueueInBatch(events);\n}\n\nvar topLevelTypes = BrowserEventConstants.topLevelTypes;\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} contentDocumentHandle Document which owns the container\n */\nfunction listenTo(registrationName, contentDocumentHandle) {\n  var mountAt = contentDocumentHandle;\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      if (dependency === 'topScroll') {\n        trapCapturedEvent('topScroll', 'scroll', mountAt);\n      } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n        trapCapturedEvent('topFocus', 'focus', mountAt);\n        trapCapturedEvent('topBlur', 'blur', mountAt);\n\n        // to make sure blur and focus event listeners are only attached once\n        isListening.topBlur = true;\n        isListening.topFocus = true;\n      } else if (dependency === 'topCancel') {\n        if (isEventSupported('cancel', true)) {\n          trapCapturedEvent('topCancel', 'cancel', mountAt);\n        }\n        isListening.topCancel = true;\n      } else if (dependency === 'topClose') {\n        if (isEventSupported('close', true)) {\n          trapCapturedEvent('topClose', 'close', mountAt);\n        }\n        isListening.topClose = true;\n      } else if (topLevelTypes.hasOwnProperty(dependency)) {\n        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n      }\n\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode$$1 = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode$$1.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElement();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElement();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    focusNode(priorFocusedElem);\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case 'topFocus':\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case 'topBlur':\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case 'topMouseDown':\n        mouseDown = true;\n        break;\n      case 'topContextMenu':\n      case 'topMouseUp':\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case 'topSelectionChange':\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case 'topKeyDown':\n      case 'topKeyUp':\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar AnimationEventInterface = {\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar TransitionEventInterface = {\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: ['topAbort'],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = {\n *   'topAbort': { sameConfig }\n * };\n */\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n  var topEvent = 'top' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent]\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case 'topKeyPress':\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case 'topKeyDown':\n      case 'topKeyUp':\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case 'topBlur':\n      case 'topFocus':\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case 'topClick':\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case 'topDoubleClick':\n      case 'topMouseDown':\n      case 'topMouseMove':\n      case 'topMouseUp':\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case 'topMouseOut':\n      case 'topMouseOver':\n      case 'topContextMenu':\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case 'topDrag':\n      case 'topDragEnd':\n      case 'topDragEnter':\n      case 'topDragExit':\n      case 'topDragLeave':\n      case 'topDragOver':\n      case 'topDragStart':\n      case 'topDrop':\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case 'topTouchCancel':\n      case 'topTouchEnd':\n      case 'topTouchMove':\n      case 'topTouchStart':\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case 'topAnimationEnd':\n      case 'topAnimationIteration':\n      case 'topAnimationStart':\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case 'topTransitionEnd':\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case 'topCopy':\n      case 'topCut':\n      case 'topPaste':\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent$1;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nsetHandleTopLevel(handleTopLevel);\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection$1.injectEventPluginOrder(DOMEventPluginOrder);\ninjection$2.injectComponentTree(ReactDOMComponentTree);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection$1.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\nvar enableAsyncSubtreeAPI = true;\nvar enableAsyncSchedulingByDefaultInReactDOM = false;\n// Exports ReactDOM.createRoot\nvar enableCreateRoot = false;\nvar enableUserTimingAPI = true;\n\n// Mutating mode (React DOM, React ART, React Native):\nvar enableMutatingReconciler = true;\n// Experimental noop mode (currently unused):\nvar enableNoopReconciler = false;\n// Experimental persistent mode (CS):\nvar enablePersistentReconciler = false;\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// Only used in www builds.\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\n\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset$1() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case ReturnComponent:\n    case Fragment:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber['return'];\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber['return'] !== null) {\n    resumeTimersRecursively(fiber['return']);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\n{\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(fiber) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node['return'];\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\nvar NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\nvar Sync = 1;\nvar Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncUpdates = 1;\n\n{\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    \n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n  workInProgress.pendingProps = pendingProps;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nfunction createFiberFromElement(element, internalContextTag, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type,\n      key = element.key;\n\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n    fiber.pendingProps = element.props;\n  } else {\n    var info = '';\n    {\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n      var ownerName = owner ? getComponentName(owner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n  var fiber = createFiber(Fragment, key, internalContextTag);\n  fiber.pendingProps = elements;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostText, null, internalContextTag);\n  fiber.pendingProps = content;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromCall(call, internalContextTag, expirationTime) {\n  var fiber = createFiber(CallComponent, call.key, internalContextTag);\n  fiber.type = call.handler;\n  fiber.pendingProps = call;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n  var fiber = createFiber(ReturnComponent, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n  fiber.pendingProps = portal.children || [];\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n{\n  var didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n    return NoWork;\n  }\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  return updateQueue.expirationTime;\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    var updateFn = partialState;\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    if (debugRenderPhaseSideEffects) {\n      updateFn.call(instance, prevState, props);\n    }\n\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n{\n  var didWarnAboutStateAssignmentForComponent = {};\n\n  var warnOnInvalidCallback = function (callback, callerName) {\n    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      stopPhaseTimer();\n\n      // Simulate an async bailout/interruption by invoking lifecycle twice.\n      if (debugRenderPhaseSideEffects) {\n        instance.shouldComponentUpdate(newProps, newState, newContext);\n      }\n\n      {\n        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n      var noInstancePropTypes = !instance.propTypes;\n      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n    }\n    if (typeof instance.getChildContext === 'function') {\n      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, 'componentWillMount');\n    var oldState = instance.state;\n    instance.componentWillMount();\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillMount();\n    }\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = processUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = processUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n    } else {\n      newState = oldState;\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        instance.componentWillUpdate(newProps, newState, newContext);\n        stopPhaseTimer();\n\n        // Simulate an async bailout/interruption by invoking lifecycle twice.\n        if (debugRenderPhaseSideEffects) {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n  var ownerHasFunctionTypeWarning = {};\n\n  var warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      created.ref = coerceRef(current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updateCall(returnFiber, current, call, expirationTime) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CallComponent) {\n      // Insert\n      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, call, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateReturn(returnFiber, current, returnNode, expirationTime) {\n    if (current === null || current.tag !== ReturnComponent) {\n      // Insert\n      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n      created.type = returnNode.value;\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, null, expirationTime);\n      existing.type = returnNode.value;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n              _created['return'] = returnFiber;\n              return _created;\n            } else {\n              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n              _created2.ref = coerceRef(null, newChild);\n              _created2['return'] = returnFiber;\n              return _created2;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n            _created3['return'] = returnFiber;\n            return _created3;\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n            _created4.type = newChild.value;\n            _created4['return'] = returnFiber;\n            return _created4;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n            _created5['return'] = returnFiber;\n            return _created5;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n        _created6['return'] = returnFiber;\n        return _created6;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys. If the previous node is implicitly keyed\n            // we can continue to replace it without aborting even if it is not a\n            // yield.\n            if (key === null) {\n              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys, so we neither have to check the old nor\n            // new node for the key. If both are returns, they match.\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_CALL_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      _created7.ref = coerceRef(currentFirstChild, element);\n      _created7['return'] = returnFiber;\n      return _created7;\n    }\n  }\n\n  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n    var key = call.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CallComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === ReturnComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, null, expirationTime);\n        existing.type = returnNode.value;\n        existing['return'] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n    created.type = returnNode.value;\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n{\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      useSyncScheduling = config.useSyncScheduling,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    var memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects) {\n        instance.render();\n      }\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = memoizedProps;\n      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress);\n        warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextCall = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCall === null) {\n        nextCall = current && current.memoizedProps;\n        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n      nextCall = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCall.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextCall);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, renderExpirationTime) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    // This is a weird case where we do \"resume\" work  work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n    if (workInProgress.tag === ClassComponent) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.type);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var call = workInProgress.memoizedProps;\n    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = call.handler;\n    var props = call.props;\n    var nextChildren = fn(props, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          if (finalizeContainerChildren(container, newChildSet)) {\n            markUpdate(workInProgress);\n          }\n          portalOrRoot.pendingChildren = newChildSet;\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    // Get the latest props.\n    var newProps = workInProgress.pendingProps;\n    if (newProps === null) {\n      newProps = workInProgress.memoizedProps;\n    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n      // Reset the pending props, unless this was a down-prioritization.\n      workInProgress.pendingProps = null;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popContextProvider(workInProgress);\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar ReactFiberCommitWork = function (config, captureError) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  var callComponentWillUnmountWithTimer = function (current, instance) {\n    startPhaseTimer(current, 'componentWillUnmount');\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidMount();\n              stopPhaseTimer();\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidUpdate(prevProps, prevState);\n              stopPhaseTimer();\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, instance);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n            commitCallbacks(_updateQueue, _instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var instance = current.stateNode;\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      var emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          var instance = canHydrateInstance(nextInstance, type, props);\n          if (instance !== null) {\n            fiber.stateNode = instance;\n            return true;\n          }\n          return false;\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          var textInstance = canHydrateTextInstance(nextInstance, text);\n          if (textInstance !== null) {\n            fiber.stateNode = textInstance;\n            return true;\n          }\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar defaultShowDialog = function (capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\n{\n  var didWarnAboutStateTransition = false;\n  var didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  var warnAboutUpdateOnUnmounted = function (fiber) {\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  var warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext,\n      resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork,\n      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      cancelDeferredCallback = config.cancelDeferredCallback,\n      useSyncScheduling = config.useSyncScheduling,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var startTime = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset$1();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            isUnmounting = true;\n            commitDeletion(nextEffect);\n            isUnmounting = false;\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        recordEffect();\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    if (firstUncaughtError !== null) {\n      var _error3 = firstUncaughtError;\n      firstUncaughtError = null;\n      onUncaughtError(_error3);\n    }\n\n    var remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n      var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      stopWorkTimer(workInProgress);\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        var root = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(expirationTime) {\n    if (capturedErrors !== null) {\n      // If there are unhandled errors, switch to the slow work loop.\n      // TODO: How to avoid this check in the fast path? Maybe the renderer\n      // could keep track of which roots have unhandled errors and call a\n      // forked version of renderRoot.\n      slowWorkLoopThatChecksForFailedWork(expirationTime);\n      return;\n    }\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n  }\n\n  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(expirationTime);\n  }\n\n  function renderRoot(root, expirationTime) {\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n    }\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback$1(null, workLoop, null, expirationTime);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    var uncaughtError = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    stopWorkLoopTimer(interruptedBy);\n    interruptedBy = null;\n    isWorking = false;\n    didFatal = false;\n    firstUncaughtError = null;\n\n    if (uncaughtError !== null) {\n      onUncaughtError(uncaughtError);\n    }\n\n    return root.isReadyForCommit ? root.current.alternate : null;\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork['return'];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary - we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node['return'];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      var _componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        var suppressLogging = e && e.suppressReactErrorLogging;\n        if (!suppressLogging) {\n          console.error(e);\n        }\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors['delete'](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n        }\n      }\n    }\n\n    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        stopFailedWorkTimer(node);\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node['return'];\n    }\n  }\n\n  function computeAsyncExpiration() {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var currentTime = recalculateCurrentTime();\n    var expirationMs = 1000;\n    var bucketSizeMs = 200;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n        // This is a sync update\n        expirationTime = Sync;\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration();\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function checkRootNeedsClearing(root, fiber, expirationTime) {\n    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {\n      // Restart the root from the top.\n      if (nextUnitOfWork !== null) {\n        // This is an interruption. (Used for performance tracking.)\n        interruptedBy = fiber;\n      }\n      nextRoot = null;\n      nextUnitOfWork = null;\n      nextRenderExpirationTime = NoWork;\n    }\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n          requestWork(root, expirationTime);\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleWorkImpl(fiber, Sync, true);\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    var ms = now() - startTime;\n    mostRecentCurrentTime = msToExpirationTime(ms);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = computeAsyncExpiration();\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  function syncUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - startTime;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n    }\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, dl);\n  }\n\n  function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      // Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    // TODO: Pass current time as argument to renderRoot, commitRoot\n    if (expirationTime <= recalculateCurrentTime()) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n  // tuple of (isReadyForCommit, didError, error)\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, null);\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn();\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn();\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n      performWork(Sync, null);\n    }\n  }\n\n  return {\n    computeAsyncExpiration: computeAsyncExpiration,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates\n  };\n};\n\n{\n  var didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\nvar ReactFiberReconciler$1 = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function scheduleTopLevelUpdate(current, element, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    }\n\n    var expirationTime = void 0;\n    // Check if the top-level element is an async wrapper component. If so,\n    // treat updates to the root as async. This is a bit weird but lets us\n    // avoid a separate `renderAsync` API.\n    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      nextCallback: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function (containerInfo, hydrate) {\n      return createFiberRoot(containerInfo, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      // TODO: If this is a nested container, this won't be the root.\n      var current = container.current;\n\n      {\n        if (ReactFiberInstrumentation_1.debugTool) {\n          if (current.alternate === null) {\n            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n\n      var context = getContextForSubtree(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      scheduleTopLevelUpdate(current, element, callback);\n    },\n\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function (devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(_assign({}, devToolsConfig, {\n        findHostInstanceByFiber: function (fiber) {\n          return findHostInstance(fiber);\n        },\n        findFiberByHostInstance: function (instance) {\n          if (!findFiberByHostInstance) {\n            // Might not be implemented by the renderer.\n            return null;\n          }\n          return findFiberByHostInstance(instance);\n        }\n      }));\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n\tdefault: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.2.0';\n\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n{\n  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar now = void 0;\nif (hasNativePerformanceNow) {\n  now = function () {\n    return performance.now();\n  };\n} else {\n  now = function () {\n    return Date.now();\n  };\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nvar rIC = void 0;\nvar cIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    return setTimeout(function () {\n      frameCallback({\n        timeRemaining: function () {\n          return Infinity;\n        }\n      });\n    });\n  };\n  cIC = function (timeoutID) {\n    clearTimeout(timeoutID);\n  };\n} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback and cancelIdleCallback\n\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject;\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = frameDeadline - performance.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // Fallback to Date.now()\n        var remaining = frameDeadline - Date.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  }\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = now();\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        frameDeadlineObject.didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrame(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    } else {\n      // There's still time left in this idle period.\n      frameDeadlineObject.didTimeout = false;\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  rIC = function (callback, options) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = now() + options.timeout;\n    }\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n\n  cIC = function () {\n    scheduledRICCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n} else {\n  rIC = window.requestIdleCallback;\n  cIC = window.cancelIdleCallback;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\n// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\n// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nfunction shouldIgnoreValue(propertyInfo, value) {\n  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\n\n\n\n\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected) {\n  {\n    var propertyInfo = getPropertyInfo(name);\n    if (propertyInfo) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod || propertyInfo.mustUseProperty) {\n        return node[propertyInfo.propertyName];\n      } else {\n        var attributeName = propertyInfo.attributeName;\n\n        var stringValue = null;\n\n        if (propertyInfo.hasOverloadedBooleanValue) {\n          if (node.hasAttribute(attributeName)) {\n            var value = node.getAttribute(attributeName);\n            if (value === '') {\n              return true;\n            }\n            if (shouldIgnoreValue(propertyInfo, expected)) {\n              return value;\n            }\n            if (value === '' + expected) {\n              return expected;\n            }\n            return value;\n          }\n        } else if (node.hasAttribute(attributeName)) {\n          if (shouldIgnoreValue(propertyInfo, expected)) {\n            // We had an attribute but shouldn't have had one, so read it\n            // for the error message.\n            return node.getAttribute(attributeName);\n          }\n          if (propertyInfo.hasBooleanValue) {\n            // If this was a boolean, it doesn't matter what the value is\n            // the fact that we have it is the same as the expected.\n            return expected;\n          }\n          // Even if this property uses a namespace we use getAttribute\n          // because we assume its namespaced name is the same as our config.\n          // To use getAttributeNS we need the local name which we don't have\n          // in our config atm.\n          stringValue = node.getAttribute(attributeName);\n        }\n\n        if (shouldIgnoreValue(propertyInfo, expected)) {\n          return stringValue === null ? expected : stringValue;\n        } else if (stringValue === '' + expected) {\n          return expected;\n        } else {\n          return stringValue;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value) {\n  var propertyInfo = getPropertyInfo(name);\n\n  if (propertyInfo && shouldSetAttribute(name, value)) {\n    var mutationMethod = propertyInfo.mutationMethod;\n    if (mutationMethod) {\n      mutationMethod(node, value);\n    } else if (shouldIgnoreValue(propertyInfo, value)) {\n      deleteValueForProperty(node, name);\n      return;\n    } else if (propertyInfo.mustUseProperty) {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyInfo.propertyName] = value;\n    } else {\n      var attributeName = propertyInfo.attributeName;\n      var namespace = propertyInfo.attributeNamespace;\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      if (namespace) {\n        node.setAttributeNS(namespace, attributeName, '' + value);\n      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n        node.setAttribute(attributeName, '');\n      } else {\n        node.setAttribute(attributeName, '' + value);\n      }\n    }\n  } else {\n    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);\n    return;\n  }\n\n  {\n    \n  }\n}\n\nfunction setValueForAttribute(node, name, value) {\n  if (!isAttributeNameSafe(name)) {\n    return;\n  }\n  if (value == null) {\n    node.removeAttribute(name);\n  } else {\n    node.setAttribute(name, '' + value);\n  }\n\n  {\n    \n  }\n}\n\n/**\n * Deletes an attributes from a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n */\nfunction deleteValueForAttribute(node, name) {\n  node.removeAttribute(name);\n}\n\n/**\n * Deletes the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n */\nfunction deleteValueForProperty(node, name) {\n  var propertyInfo = getPropertyInfo(name);\n  if (propertyInfo) {\n    var mutationMethod = propertyInfo.mutationMethod;\n    if (mutationMethod) {\n      mutationMethod(node, undefined);\n    } else if (propertyInfo.mustUseProperty) {\n      var propName = propertyInfo.propertyName;\n      if (propertyInfo.hasBooleanValue) {\n        node[propName] = false;\n      } else {\n        node[propName] = '';\n      }\n    } else {\n      node.removeAttribute(propertyInfo.attributeName);\n    }\n  } else {\n    node.removeAttribute(name);\n  }\n}\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var value = props.value;\n  var checked = props.checked;\n\n  var hostProps = _assign({\n    // Make sure we set .type before any other properties (setting .value\n    // before .type means .value is lost in IE11 and below)\n    type: undefined,\n    // Make sure we set .step before .value (setting .value before .step\n    // means .value is rounded on mount, based upon step precision)\n    step: undefined,\n    // Make sure we set .min & .max before .value (to ensure proper order\n    // in corner cases such as min or max deriving from value, e.g. Issue #7170)\n    min: undefined,\n    max: undefined\n  }, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: value != null ? value : node._wrapperState.initialValue,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var defaultValue = props.defaultValue;\n  var node = element;\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: props.value != null ? props.value : defaultValue,\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = props.value;\n  if (value != null) {\n    if (value === 0 && node.value === '') {\n      node.value = '0';\n      // Note: IE9 reports a number inputs as 'text', so check props instead.\n    } else if (props.type === 'number') {\n      // Simulate `input.valueAsNumber`. IE9 does not support it\n      var valueAsNumber = parseFloat(node.value) || 0;\n\n      if (\n      // eslint-disable-next-line\n      value != valueAsNumber ||\n      // eslint-disable-next-line\n      value == valueAsNumber && node.value != value) {\n        // Cast `value` to a string to ensure the value is set correctly. While\n        // browsers typically do this as necessary, jsdom doesn't.\n        node.value = '' + value;\n      }\n    } else if (node.value !== '' + value) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      node.value = '' + value;\n    }\n  } else {\n    if (props.value == null && props.defaultValue != null) {\n      // In Chrome, assigning defaultValue to certain input types triggers input validation.\n      // For number inputs, the display value loses trailing decimal points. For email inputs,\n      // Chrome raises \"The specified value <x> is not a valid email address\".\n      //\n      // Here we check to see if the defaultValue has actually changed, avoiding these problems\n      // when the user is inputting text\n      //\n      // https://github.com/facebook/react/issues/7253\n      if (node.defaultValue !== '' + props.defaultValue) {\n        node.defaultValue = '' + props.defaultValue;\n      }\n    }\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\n\nfunction postMountWrapper(element, props) {\n  var node = element;\n\n  // Detach value from defaultValue. We won't do anything if we're working on\n  // submit or reset inputs as those values & defaultValues are linked. They\n  // are not resetable nodes so this operation doesn't matter and actually\n  // removes browser-default values (eg \"Submit Query\") when no value is\n  // provided.\n\n  switch (props.type) {\n    case 'submit':\n    case 'reset':\n      break;\n    case 'color':\n    case 'date':\n    case 'datetime':\n    case 'datetime-local':\n    case 'month':\n    case 'time':\n    case 'week':\n      // This fixes the no-show issue on iOS Safari and Android Chrome:\n      // https://github.com/facebook/react/issues/7233\n      node.value = '';\n      node.value = node.defaultValue;\n      break;\n    default:\n      node.value = node.value;\n      break;\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n  node.defaultChecked = !node.defaultChecked;\n  node.defaultChecked = !node.defaultChecked;\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState$1(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  // TODO (yungsters): Remove support for `selected` in <option>.\n  {\n    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', props.value);\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$3();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  var value = props.value;\n  node._wrapperState = {\n    initialValue: value != null ? value : props.defaultValue,\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  // After the initial mount, we control selected-ness manually so don't pass\n  // this value down\n  node._wrapperState.initialValue = undefined;\n\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: '' + node._wrapperState.initialValue\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: '' + initialValue\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = props.value;\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = '' + value;\n\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = props.defaultValue;\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node, ensuring that whitespace is preserved\n * even in IE8. innerText is a poor substitute for textContent and, among many\n * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n * as it should.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar warnValidStyle = emptyFunction;\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n  };\n\n  var warnBadVendoredStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, getStack) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n  };\n\n  var warnStyleValueIsNaN = function (name, value, getStack) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, getStack) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  warnValidStyle = function (name, value, getStack) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, getStack);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, getStack);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, getStack);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, getStack);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, getStack);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles, getStack) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName], getStack);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\nvar HTML$1 = '__html';\n\nfunction assertValidProps(tag, props, getStack) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getStackAddendum() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  } else if (invalidProps.length > 1) {\n    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n    } else {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n    }\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  'class': 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  'default': 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  'for': 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  'in': 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  'typeof': 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nfunction getStackAddendum$2() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\n{\n  var warnedProperties$1 = {};\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var isReserved = isReservedProp(name);\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {\n      if (value) {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n      } else {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (!shouldSetAttribute(name, value)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  } else if (unknownProps.length > 1) {\n    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar getStack = emptyFunction.thatReturns('');\n\n{\n  getStack = getCurrentFiberStackAddendum$2;\n\n  var warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true\n  };\n\n  var validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  var normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  var warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  var warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  var warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning(false, 'Extra attributes from the server: %s', names);\n  };\n\n  var warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());\n    } else {\n      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  var normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\n// There are so many media events, it makes sense to just\n// maintain a list rather than create a `trapBubbledEvent` for each\nvar mediaEvents = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We blacklist it here rather than in the property list because we emit it in SSR.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (isCustomComponentTag) {\n      setValueForAttribute(domElement, propKey, nextProp);\n    } else if (nextProp != null) {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      setValueForProperty(domElement, propKey, nextProp);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else if (isCustomComponentTag) {\n      if (propValue != null) {\n        setValueForAttribute(domElement, propKey, propValue);\n      } else {\n        deleteValueForAttribute(domElement, propKey);\n      }\n    } else if (propValue != null) {\n      setValueForProperty(domElement, propKey, propValue);\n    } else {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      deleteValueForProperty(domElement, propKey);\n    }\n  }\n}\n\nfunction createElement$1(type, props, rootContainerElement, parentNamespace) {\n  // We create tags in the namespace of their parent container, except HTML\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      var isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode$1(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEvents[event], domElement);\n        }\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props, getStack);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps;\n  var nextProps;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps, getStack);\n\n  var propKey;\n  var styleName;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  {\n    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    var isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEvents[event], domElement);\n        }\n      }\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      break;\n    case 'img':\n    case 'image':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps, getStack);\n\n  {\n    var extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var i = 0; i < attributes.length; i++) {\n      var name = attributes[i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else {\n      // Validate that the properties correspond to their expected values.\n      var serverValue;\n      var propertyInfo;\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n        var serverHTML = domElement.innerHTML;\n        var expectedHTML = normalizeHTML(domElement, rawHtml);\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey);\n        var expectedStyle = createDangerousStringForStyles(nextProp);\n        serverValue = domElement.getAttribute('style');\n        if (expectedStyle !== serverValue) {\n          warnForPropDifference(propKey, serverValue, expectedStyle);\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (shouldSetAttribute(propKey, nextProp)) {\n        if (propertyInfo = getPropertyInfo(propKey)) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey.toLowerCase());\n          } else {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText$1(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText$1(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement$1(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText$1(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState$1(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\nvar ReactDOMFiberComponent = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateTextNode: createTextNode$1,\n\tsetInitialProperties: setInitialProperties$1,\n\tdiffProperties: diffProperties$1,\n\tupdateProperties: updateProperties$1,\n\tdiffHydratedProperties: diffHydratedProperties$1,\n\tdiffHydratedText: diffHydratedText$1,\n\twarnForUnmatchedText: warnForUnmatchedText$1,\n\twarnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n\twarnForDeletedHydratableText: warnForDeletedHydratableText$1,\n\twarnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n\twarnForInsertedHydratedText: warnForInsertedHydratedText$1,\n\trestoreControlledState: restoreControlledState\n});\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar validateDOMNesting = emptyFunction;\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackAddendum$6();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  // TODO: turn this into a named export\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;\n\n  // For testing\n  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n  };\n}\n\nvar validateDOMNesting$1 = validateDOMNesting;\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar createElement = createElement$1;\nvar createTextNode = createTextNode$1;\nvar setInitialProperties = setInitialProperties$1;\nvar diffProperties = diffProperties$1;\nvar updateProperties = updateProperties$1;\nvar diffHydratedProperties = diffHydratedProperties$1;\nvar diffHydratedText = diffHydratedText$1;\nvar warnForUnmatchedText = warnForUnmatchedText$1;\nvar warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\nvar warnForDeletedHydratableText = warnForDeletedHydratableText$1;\nvar warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\nvar warnForInsertedHydratedText = warnForInsertedHydratedText$1;\nvar updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\nvar precacheFiberNode = precacheFiberNode$1;\nvar updateFiberProps = updateFiberProps$1;\n\n\n{\n  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\ninjection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nvar DOMRenderer = reactReconciler({\n  getRootHostContext: function (rootContainerInstance) {\n    var type = void 0;\n    var namespace = void 0;\n    var nodeType = rootContainerInstance.nodeType;\n    switch (nodeType) {\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        {\n          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n          var root = rootContainerInstance.documentElement;\n          namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n          break;\n        }\n      default:\n        {\n          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n          var ownNamespace = container.namespaceURI || null;\n          type = container.tagName;\n          namespace = getChildNamespace(ownNamespace, type);\n          break;\n        }\n    }\n    {\n      var validatedTag = type.toLowerCase();\n      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n      return { namespace: namespace, ancestorInfo: _ancestorInfo };\n    }\n    return namespace;\n  },\n  getChildHostContext: function (parentHostContext, type) {\n    {\n      var parentHostContextDev = parentHostContext;\n      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n    }\n    var parentNamespace = parentHostContext;\n    return getChildNamespace(parentNamespace, type);\n  },\n  getPublicInstance: function (instance) {\n    return instance;\n  },\n  prepareForCommit: function () {\n    eventsEnabled = isEnabled();\n    selectionInformation = getSelectionInformation();\n    setEnabled(false);\n  },\n  resetAfterCommit: function () {\n    restoreSelection(selectionInformation);\n    selectionInformation = null;\n    setEnabled(eventsEnabled);\n    eventsEnabled = null;\n  },\n  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    var parentNamespace = void 0;\n    {\n      // TODO: take namespace into account when validating.\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        var string = '' + props.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n      parentNamespace = hostContextDev.namespace;\n    }\n    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n    precacheFiberNode(internalInstanceHandle, domElement);\n    updateFiberProps(domElement, props);\n    return domElement;\n  },\n  appendInitialChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n    setInitialProperties(domElement, type, props, rootContainerInstance);\n    return shouldAutoFocusHostComponent(type, props);\n  },\n  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    {\n      var hostContextDev = hostContext;\n      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n        var string = '' + newProps.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n    }\n    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n  },\n  shouldSetTextContent: function (type, props) {\n    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n  },\n  shouldDeprioritizeSubtree: function (type, props) {\n    return !!props.hidden;\n  },\n  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n    {\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n    }\n    var textNode = createTextNode(text, rootContainerInstance);\n    precacheFiberNode(internalInstanceHandle, textNode);\n    return textNode;\n  },\n\n\n  now: now,\n\n  mutation: {\n    commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n      domElement.focus();\n    },\n    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n      // Update the props handle so that we know which props are the ones with\n      // with current event handlers.\n      updateFiberProps(domElement, newProps);\n      // Apply the diff to the DOM node.\n      updateProperties(domElement, updatePayload, type, oldProps, newProps);\n    },\n    resetTextContent: function (domElement) {\n      domElement.textContent = '';\n    },\n    commitTextUpdate: function (textInstance, oldText, newText) {\n      textInstance.nodeValue = newText;\n    },\n    appendChild: function (parentInstance, child) {\n      parentInstance.appendChild(child);\n    },\n    appendChildToContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, container);\n      } else {\n        container.appendChild(child);\n      }\n    },\n    insertBefore: function (parentInstance, child, beforeChild) {\n      parentInstance.insertBefore(child, beforeChild);\n    },\n    insertInContainerBefore: function (container, child, beforeChild) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, beforeChild);\n      } else {\n        container.insertBefore(child, beforeChild);\n      }\n    },\n    removeChild: function (parentInstance, child) {\n      parentInstance.removeChild(child);\n    },\n    removeChildFromContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.removeChild(child);\n      } else {\n        container.removeChild(child);\n      }\n    }\n  },\n\n  hydration: {\n    canHydrateInstance: function (instance, type, props) {\n      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n        return null;\n      }\n      // This has now been refined to an element node.\n      return instance;\n    },\n    canHydrateTextInstance: function (instance, text) {\n      if (text === '' || instance.nodeType !== TEXT_NODE) {\n        // Empty strings are not parsed by HTML so there won't be a correct match here.\n        return null;\n      }\n      // This has now been refined to a text node.\n      return instance;\n    },\n    getNextHydratableSibling: function (instance) {\n      var node = instance.nextSibling;\n      // Skip non-hydratable nodes.\n      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    },\n    getFirstHydratableChild: function (parentInstance) {\n      var next = parentInstance.firstChild;\n      // Skip non-hydratable nodes.\n      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n        next = next.nextSibling;\n      }\n      return next;\n    },\n    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, instance);\n      // TODO: Possibly defer this until the commit phase where all the events\n      // get attached.\n      updateFiberProps(instance, props);\n      var parentNamespace = void 0;\n      {\n        var hostContextDev = hostContext;\n        parentNamespace = hostContextDev.namespace;\n      }\n      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n    },\n    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, textInstance);\n      return diffHydratedText(textInstance, text);\n    },\n    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {\n      {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotHydrateContainerInstance: function (parentContainer, instance) {\n      {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentContainer, instance);\n        } else {\n          warnForDeletedHydratableText(parentContainer, instance);\n        }\n      }\n    },\n    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentInstance, instance);\n        } else {\n          warnForDeletedHydratableText(parentInstance, instance);\n        }\n      }\n    },\n    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {\n      {\n        warnForInsertedHydratedElement(parentContainer, type, props);\n      }\n    },\n    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {\n      {\n        warnForInsertedHydratedText(parentContainer, text);\n      }\n    },\n    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedElement(parentInstance, type, props);\n      }\n    },\n    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedText(parentInstance, text);\n      }\n    }\n  },\n\n  scheduleDeferredCallback: rIC,\n  cancelDeferredCallback: cIC,\n\n  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM\n});\n\ninjection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);\n      if (hostInstance) {\n        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n\n    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n  }\n\n  var root = container._reactRootContainer;\n  if (!root) {\n    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    // First clear any existing content.\n    if (!shouldHydrate) {\n      var warned = false;\n      var rootSibling = void 0;\n      while (rootSibling = container.lastChild) {\n        {\n          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n            warned = true;\n            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n          }\n        }\n        container.removeChild(rootSibling);\n      }\n    }\n    {\n      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n        warnedAboutHydrateAPI = true;\n        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n      }\n    }\n    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);\n    root = container._reactRootContainer = newRoot;\n    // Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n    });\n  } else {\n    DOMRenderer.updateContainer(children, root, parentComponent, callback);\n  }\n  return DOMRenderer.getPublicRootInstance(root);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nfunction ReactRoot(container, hydrate) {\n  var root = DOMRenderer.createContainer(container, hydrate);\n  this._reactRootContainer = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._reactRootContainer;\n  DOMRenderer.updateContainer(children, root, null, callback);\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._reactRootContainer;\n  DOMRenderer.updateContainer(null, root, null, callback);\n};\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    var inst = get(componentOrElement);\n    if (inst) {\n      return DOMRenderer.findHostInstance(inst);\n    }\n\n    if (typeof componentOrElement.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));\n    }\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return renderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return renderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        warning(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n      }\n\n      // Unmount should not be batched.\n      DOMRenderer.unbatchedUpdates(function () {\n        renderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        warning(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: createPortal,\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n\n  flushSync: DOMRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry,\n    EventPropagators: EventPropagators,\n    ReactControlledComponent: ReactControlledComponent,\n    ReactDOMComponentTree: ReactDOMComponentTree,\n    ReactDOMEventListener: ReactDOMEventListener\n  }\n};\n\nif (enableCreateRoot) {\n  ReactDOM.createRoot = function createRoot(container, options) {\n    var hydrate = options != null && options.hydrate === true;\n    return new ReactRoot(container, hydrate);\n  };\n}\n\nvar foundDevTools = DOMRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n","'use strict';\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.min.js');\n} else {\n  module.exports = require('./cjs/react-dom.development.js');\n}\n","/** @license React v16.2.0\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar _assign = require('object-assign');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar checkPropTypes = require('prop-types/checkPropTypes');\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.2.0';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var constructor = publicInstance.constructor;\n    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\\n\\nPlease check the code for the %s component.', callerName, callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction PureComponent(props, context, updater) {\n  // Duplicated from Component.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\nfunction AsyncComponent(props, context, updater) {\n  // Duplicated from Component.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();\nasyncComponentPrototype.constructor = AsyncComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(asyncComponentPrototype, Component.prototype);\nasyncComponentPrototype.unstable_isAsyncReactComponent = true;\nasyncComponentPrototype.render = function () {\n  return this.props.children;\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allow us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  var propName;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar ReactDebugCurrentFrame = {};\n\n{\n  // Component that is being worked on\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      return impl();\n    }\n    return null;\n  };\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_CALL_TYPE:\n          case REACT_RETURN_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.toarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\n{\n  var currentlyValidatingElement = null;\n\n  var propTypesMisspellWarningShown = false;\n\n  var getDisplayName = function (element) {\n    if (element == null) {\n      return '#empty';\n    } else if (typeof element === 'string' || typeof element === 'number') {\n      return '#text';\n    } else if (typeof element.type === 'string') {\n      return element.type;\n    } else if (element.type === REACT_FRAGMENT_TYPE) {\n      return 'React.Fragment';\n    } else {\n      return element.type.displayName || element.type.name || 'Unknown';\n    }\n  };\n\n  var getStackAddendum = function () {\n    var stack = '';\n    if (currentlyValidatingElement) {\n      var name = getDisplayName(currentlyValidatingElement);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n    }\n    stack += ReactDebugCurrentFrame.getStackAddendum() || '';\n    return stack;\n  };\n\n  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n  }\n\n  currentlyValidatingElement = element;\n  {\n    warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\n  }\n  currentlyValidatingElement = null;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var componentClass = element.type;\n  if (typeof componentClass !== 'function') {\n    return;\n  }\n  var name = componentClass.displayName || componentClass.name;\n  var propTypes = componentClass.propTypes;\n  if (propTypes) {\n    currentlyValidatingElement = element;\n    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\n    currentlyValidatingElement = null;\n  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  currentlyValidatingElement = fragment;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      if (!VALID_FRAGMENT_PROPS.has(key)) {\n        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\n  }\n\n  currentlyValidatingElement = null;\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    info += getStackAddendum() || '';\n\n    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  // Legacy hook TODO: Warn if this is accessed\n  validatedFactory.type = type;\n\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  Component: Component,\n  PureComponent: PureComponent,\n  unstable_AsyncComponent: AsyncComponent,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: ReactCurrentOwner,\n    // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n    assign: _assign\n  }\n};\n\n{\n  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3['default'] ? React$3['default'] : React$3;\n\nmodule.exports = react;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","/*!\n * ngTagsInput v2.3.0\n * http://mbenford.github.io/ngTagsInput\n *\n * Copyright (c) 2013-2015 Michael Benford\n * License: MIT\n *\n * Generated at 2015-03-24 00:49:44 -0300\n */\n(function() {\n'use strict';\n\nvar KEYS = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    left: 37,\n    right: 39,\n    delete: 46,\n    comma: 188\n};\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];\n\nvar tagsInput = angular.module('ngTagsInput', []);\n\n/**\n * @ngdoc directive\n * @name tagsInput\n * @module ngTagsInput\n *\n * @description\n * Renders an input box with tag editing support.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} [displayProperty=text] Property to be rendered as the tag label.\n * @param {string=} [keyProperty=text] Property to be used as a unique identifier for the tag.\n * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.\n * @param {number=} tabindex Tab order of the control.\n * @param {string=} [placeholder=Add a tag] Placeholder text for the control.\n * @param {number=} [minLength=3] Minimum length for a new tag.\n * @param {number=} [maxLength=MAX_SAFE_INTEGER] Maximum length allowed for a new tag.\n * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.\n * @param {number=} [maxTags=MAX_SAFE_INTEGER] Sets maxTags validation error key if the number of tags added is greater than maxTags.\n * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in\n *                                             the input element when the directive loses focus.\n * @param {string=} [removeTagSymbol=] Symbol character for the remove tag button.\n * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.\n * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.\n * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.\n * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.\n * @param {boolean=} [addOnPaste=false] Flag indicating that the text pasted into the input field will be split into tags.\n * @param {string=} [pasteSplitPattern=,] Regular expression used to split the pasted text into tags.\n * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.\n * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.\n * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into\n *                                                the new tag input box instead of being removed when the backspace key\n *                                                is pressed and the input box is empty.\n * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list will be allowed.\n *                                                   When this flag is true, addOnEnter, addOnComma, addOnSpace, addOnBlur and\n *                                                   allowLeftoverText values are ignored.\n * @param {boolean=} [spellcheck=true] Flag indicating whether the browser's spellcheck is enabled for the input field or not.\n * @param {expression} onTagAdding Expression to evaluate that will be invoked before adding a new tag. The new tag is available as $tag. This method must return either true or false. If false, the tag will not be added.\n * @param {expression} onTagAdded Expression to evaluate upon adding a new tag. The new tag is available as $tag.\n * @param {expression} onInvalidTag Expression to evaluate when a tag is invalid. The invalid tag is available as $tag.\n * @param {expression} onTagRemoving Expression to evaluate that will be invoked before removing a tag. The tag is available as $tag. This method must return either true or false. If false, the tag will not be removed.\n * @param {expression} onTagRemoved Expression to evaluate upon removing an existing tag. The removed tag is available as $tag.\n */\ntagsInput.directive('tagsInput', [\"$timeout\",\"$document\",\"$window\",\"tagsInputConfig\",\"tiUtil\", function($timeout, $document, $window, tagsInputConfig, tiUtil) {\n    function TagList(options, events, onTagAdding, onTagRemoving) {\n        var self = {}, getTagText, setTagText, tagIsValid;\n\n        getTagText = function(tag) {\n            return tiUtil.safeToString(tag[options.displayProperty]);\n        };\n\n        setTagText = function(tag, text) {\n            tag[options.displayProperty] = text;\n        };\n\n        tagIsValid = function(tag) {\n            var tagText = getTagText(tag);\n\n            return tagText &&\n                   tagText.length >= options.minLength &&\n                   tagText.length <= options.maxLength &&\n                   options.allowedTagsPattern.test(tagText) &&\n                   !tiUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&\n                   onTagAdding({ $tag: tag });\n        };\n\n        self.items = [];\n\n        self.addText = function(text) {\n            var tag = {};\n            setTagText(tag, text);\n            return self.add(tag);\n        };\n\n        self.add = function(tag) {\n            var tagText = getTagText(tag);\n\n            if (options.replaceSpacesWithDashes) {\n                tagText = tiUtil.replaceSpacesWithDashes(tagText);\n            }\n\n            setTagText(tag, tagText);\n\n            if (tagIsValid(tag)) {\n                self.items.push(tag);\n                events.trigger('tag-added', { $tag: tag });\n            }\n            else if (tagText) {\n                events.trigger('invalid-tag', { $tag: tag });\n            }\n\n            return tag;\n        };\n\n        self.remove = function(index) {\n            var tag = self.items[index];\n\n            if (onTagRemoving({ $tag: tag }))  {\n                self.items.splice(index, 1);\n                self.clearSelection();\n                events.trigger('tag-removed', { $tag: tag });\n                return tag;\n            }\n        };\n\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n\n            self.index = index;\n            self.selected = self.items[index];\n        };\n\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n\n        self.removeSelected = function() {\n            return self.remove(self.index);\n        };\n\n        self.clearSelection = function() {\n            self.selected = null;\n            self.index = -1;\n        };\n\n        self.clearSelection();\n\n        return self;\n    }\n\n    function validateType(type) {\n        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;\n    }\n\n    return {\n        restrict: 'E',\n        require: 'ngModel',\n        scope: {\n            tags: '=ngModel',\n            onTagAdding: '&',\n            onTagAdded: '&',\n            onInvalidTag: '&',\n            onTagRemoving: '&',\n            onTagRemoved: '&'\n        },\n        replace: false,\n        transclude: true,\n        templateUrl: 'ngTagsInput/tags-input.html',\n        controller: [\"$scope\",\"$attrs\",\"$element\", function($scope, $attrs, $element) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('tagsInput', $scope, $attrs, {\n                template: [String, 'ngTagsInput/tag-item.html'],\n                type: [String, 'text', validateType],\n                placeholder: [String, 'Add a tag'],\n                tabindex: [Number, null],\n                removeTagSymbol: [String, String.fromCharCode(215)],\n                replaceSpacesWithDashes: [Boolean, true],\n                minLength: [Number, 3],\n                maxLength: [Number, MAX_SAFE_INTEGER],\n                addOnEnter: [Boolean, true],\n                addOnSpace: [Boolean, false],\n                addOnComma: [Boolean, true],\n                addOnBlur: [Boolean, true],\n                addOnPaste: [Boolean, false],\n                pasteSplitPattern: [RegExp, /,/],\n                allowedTagsPattern: [RegExp, /.+/],\n                enableEditingLastTag: [Boolean, false],\n                minTags: [Number, 0],\n                maxTags: [Number, MAX_SAFE_INTEGER],\n                displayProperty: [String, 'text'],\n                keyProperty: [String, ''],\n                allowLeftoverText: [Boolean, false],\n                addFromAutocompleteOnly: [Boolean, false],\n                spellcheck: [Boolean, true]\n            });\n\n            $scope.tagList = new TagList($scope.options, $scope.events,\n                tiUtil.handleUndefinedResult($scope.onTagAdding, true),\n                tiUtil.handleUndefinedResult($scope.onTagRemoving, true));\n\n            this.registerAutocomplete = function() {\n                var input = $element.find('input');\n\n                return {\n                    addTag: function(tag) {\n                        return $scope.tagList.add(tag);\n                    },\n                    focusInput: function() {\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    },\n                    getTags: function() {\n                        return $scope.tags;\n                    },\n                    getCurrentTagText: function() {\n                        return $scope.newTag.text;\n                    },\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    on: function(name, handler) {\n                        $scope.events.on(name, handler);\n                        return this;\n                    }\n                };\n            };\n\n            this.registerTagItem = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    removeTag: function(index) {\n                        if ($scope.disabled) {\n                            return;\n                        }\n                        $scope.tagList.remove(index);\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, ngModelCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],\n                tagList = scope.tagList,\n                events = scope.events,\n                options = scope.options,\n                input = element.find('input'),\n                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],\n                setElementValidity;\n\n            setElementValidity = function() {\n                ngModelCtrl.$setValidity('maxTags', scope.tags.length <= options.maxTags);\n                ngModelCtrl.$setValidity('minTags', scope.tags.length >= options.minTags);\n                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text);\n            };\n\n            ngModelCtrl.$isEmpty = function(value) {\n                return !value || !value.length;\n            };\n\n            scope.newTag = {\n                text: '',\n                invalid: null,\n                setText: function(value) {\n                    this.text = value;\n                    events.trigger('input-change', value);\n                }\n            };\n\n            scope.track = function(tag) {\n                return tag[options.keyProperty || options.displayProperty];\n            };\n\n            scope.$watch('tags', function(value) {\n                scope.tags = tiUtil.makeObjectArray(value, options.displayProperty);\n                tagList.items = scope.tags;\n            });\n\n            scope.$watch('tags.length', function() {\n                setElementValidity();\n            });\n\n            attrs.$observe('disabled', function(value) {\n                scope.disabled = value;\n            });\n\n            scope.eventHandlers = {\n                input: {\n                    change: function(text) {\n                        events.trigger('input-change', text);\n                    },\n                    keydown: function($event) {\n                        events.trigger('input-keydown', $event);\n                    },\n                    focus: function() {\n                        if (scope.hasFocus) {\n                            return;\n                        }\n\n                        scope.hasFocus = true;\n                        events.trigger('input-focus');\n                    },\n                    blur: function() {\n                        $timeout(function() {\n                            var activeElement = $document.prop('activeElement'),\n                                lostFocusToBrowserWindow = activeElement === input[0],\n                                lostFocusToChildElement = element[0].contains(activeElement);\n\n                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {\n                                scope.hasFocus = false;\n                                events.trigger('input-blur');\n                            }\n                        });\n                    },\n                    paste: function($event) {\n                        $event.getTextData = function() {\n                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);\n                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');\n                        };\n                        events.trigger('input-paste', $event);\n                    }\n                },\n                host: {\n                    click: function() {\n                        if (scope.disabled) {\n                            return;\n                        }\n                        // blake_r - Stop the focus as this breaks on the\n                        // version of AngularJS that ships with MAAS.\n                        //input[0].focus();\n                    }\n                }\n            };\n\n            events\n                .on('tag-added', scope.onTagAdded)\n                .on('invalid-tag', scope.onInvalidTag)\n                .on('tag-removed', scope.onTagRemoved)\n                .on('tag-added', function() {\n                    scope.newTag.setText('');\n                })\n                .on('tag-added tag-removed', function() {\n                    // Sets the element to its dirty state\n                    // In Angular 1.3 this will be replaced with $setDirty.\n                    ngModelCtrl.$setViewValue(scope.tags);\n                })\n                .on('invalid-tag', function() {\n                    scope.newTag.invalid = true;\n                })\n                .on('option-change', function(e) {\n                    if (validationOptions.indexOf(e.name) !== -1) {\n                        setElementValidity();\n                    }\n                })\n                .on('input-change', function() {\n                    tagList.clearSelection();\n                    scope.newTag.invalid = null;\n                })\n                .on('input-focus', function() {\n                    element.triggerHandler('focus');\n                    ngModelCtrl.$setValidity('leftoverText', true);\n                })\n                .on('input-blur', function() {\n                    if (options.addOnBlur && !options.addFromAutocompleteOnly) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    element.triggerHandler('blur');\n                    setElementValidity();\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        isModifier = event.shiftKey || event.altKey || event.ctrlKey || event.metaKey,\n                        addKeys = {},\n                        shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag;\n\n                    if (isModifier || hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    addKeys[KEYS.enter] = options.addOnEnter;\n                    addKeys[KEYS.comma] = options.addOnComma;\n                    addKeys[KEYS.space] = options.addOnSpace;\n\n                    shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];\n                    shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;\n                    shouldEditLastTag = key === KEYS.backspace && scope.newTag.text.length === 0 && options.enableEditingLastTag;\n                    shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && scope.newTag.text.length === 0 && !options.enableEditingLastTag;\n\n                    if (shouldAdd) {\n                        tagList.addText(scope.newTag.text);\n                    }\n                    else if (shouldEditLastTag) {\n                        var tag;\n\n                        tagList.selectPrior();\n                        tag = tagList.removeSelected();\n\n                        if (tag) {\n                            scope.newTag.setText(tag[options.displayProperty]);\n                        }\n                    }\n                    else if (shouldRemove) {\n                        tagList.removeSelected();\n                    }\n                    else if (shouldSelect) {\n                        if (key === KEYS.left || key === KEYS.backspace) {\n                            tagList.selectPrior();\n                        }\n                        else if (key === KEYS.right) {\n                            tagList.selectNext();\n                        }\n                    }\n\n                    if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {\n                        event.preventDefault();\n                    }\n                })\n                .on('input-paste', function(event) {\n                    if (options.addOnPaste) {\n                        var data = event.getTextData();\n                        var tags = data.split(options.pasteSplitPattern);\n\n                        if (tags.length > 1) {\n                            tags.forEach(function(tag) {\n                                tagList.addText(tag);\n                            });\n                            event.preventDefault();\n                        }\n                    }\n                });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTagItem\n * @module ngTagsInput\n *\n * @description\n * Represents a tag item. Used internally by the tagsInput directive.\n */\ntagsInput.directive('tiTagItem', [\"tiUtil\", function(tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var tagsInput = tagsInputCtrl.registerTagItem(),\n                options = tagsInput.getOptions();\n\n            scope.$$template = options.template;\n            scope.$$removeTagSymbol = options.removeTagSymbol;\n\n            scope.$getDisplayText = function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty]);\n            };\n            scope.$removeTag = function() {\n                tagsInput.removeTag(scope.$index);\n            };\n\n            scope.$watch('$parent.$index', function(value) {\n                scope.$index = value;\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name autoComplete\n * @module ngTagsInput\n *\n * @description\n * Provides autocomplete support for the tagsInput directive.\n *\n * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as\n *                            $query. The result of the expression must be a promise that eventually resolves to an\n *                            array of strings.\n * @param {string=} [displayProperty=text] Property to be rendered as the autocomplete label.\n * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in\n *                                      the source option after the last keystroke.\n * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression\n *                                 in the source option.\n * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the\n *                                               suggestions list.\n * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.\n * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow\n *                                           key is pressed and the suggestion list is closed. The current input value\n *                                           is available as $query.\n * @param {boolean=} {loadOnEmpty=false} Flag indicating that the source option will be evaluated when the input content\n *                                       becomes empty. The $query variable will be passed to the expression as an empty string.\n * @param {boolean=} {loadOnFocus=false} Flag indicating that the source option will be evaluated when the input element\n *                                       gains focus. The current input value is available as $query.\n * @param {boolean=} [selectFirstMatch=true] Flag indicating that the first match will be automatically selected once\n *                                           the suggestion list is shown.\n * @param {string=} [template=] URL or id of a custom template for rendering each element of the autocomplete list.\n */\ntagsInput.directive('autoComplete', [\"$document\",\"$timeout\",\"$sce\",\"$q\",\"tagsInputConfig\",\"tiUtil\", function($document, $timeout, $sce, $q, tagsInputConfig, tiUtil) {\n    function SuggestionList(loadFn, options, events) {\n        var self = {}, getDifference, lastPromise, getTagId;\n\n        getTagId = function() {\n            return options.tagsInput.keyProperty || options.tagsInput.displayProperty;\n        };\n\n        getDifference = function(array1, array2) {\n            return array1.filter(function(item) {\n                return !tiUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {\n                    if (options.tagsInput.replaceSpacesWithDashes) {\n                        a = tiUtil.replaceSpacesWithDashes(a);\n                        b = tiUtil.replaceSpacesWithDashes(b);\n                    }\n                    return tiUtil.defaultComparer(a, b);\n                });\n            });\n        };\n\n        self.reset = function() {\n            lastPromise = null;\n\n            self.items = [];\n            self.visible = false;\n            self.index = -1;\n            self.selected = null;\n            self.query = null;\n        };\n        self.show = function() {\n            if (options.selectFirstMatch) {\n                self.select(0);\n            }\n            else {\n                self.selected = null;\n            }\n            self.visible = true;\n        };\n        self.load = tiUtil.debounce(function(query, tags) {\n            self.query = query;\n\n            var promise = $q.when(loadFn({ $query: query }));\n            lastPromise = promise;\n\n            promise.then(function(items) {\n                if (promise !== lastPromise) {\n                    return;\n                }\n\n                items = tiUtil.makeObjectArray(items.data || items, getTagId());\n                items = getDifference(items, tags);\n                self.items = items.slice(0, options.maxResultsToShow);\n\n                if (self.items.length > 0) {\n                    self.show();\n                }\n                else {\n                    self.reset();\n                }\n            });\n        }, options.debounceDelay);\n\n        self.selectNext = function() {\n            self.select(++self.index);\n        };\n        self.selectPrior = function() {\n            self.select(--self.index);\n        };\n        self.select = function(index) {\n            if (index < 0) {\n                index = self.items.length - 1;\n            }\n            else if (index >= self.items.length) {\n                index = 0;\n            }\n            self.index = index;\n            self.selected = self.items[index];\n            events.trigger('suggestion-selected', index);\n        };\n\n        self.reset();\n\n        return self;\n    }\n\n    function scrollToElement(root, index) {\n        var element = root.find('li').eq(index),\n            parent = element.parent(),\n            elementTop = element.prop('offsetTop'),\n            elementHeight = element.prop('offsetHeight'),\n            parentHeight = parent.prop('clientHeight'),\n            parentScrollTop = parent.prop('scrollTop');\n\n        if (elementTop < parentScrollTop) {\n            parent.prop('scrollTop', elementTop);\n        }\n        else if (elementTop + elementHeight > parentHeight + parentScrollTop) {\n            parent.prop('scrollTop', elementTop + elementHeight - parentHeight);\n        }\n    }\n\n    return {\n        restrict: 'E',\n        require: '^tagsInput',\n        scope: { source: '&' },\n        templateUrl: 'ngTagsInput/auto-complete.html',\n        controller: [\"$scope\",\"$element\",\"$attrs\", function($scope, $element, $attrs) {\n            $scope.events = tiUtil.simplePubSub();\n\n            tagsInputConfig.load('autoComplete', $scope, $attrs, {\n                template: [String, 'ngTagsInput/auto-complete-match.html'],\n                debounceDelay: [Number, 100],\n                minLength: [Number, 3],\n                highlightMatchedText: [Boolean, true],\n                maxResultsToShow: [Number, 10],\n                loadOnDownArrow: [Boolean, false],\n                loadOnEmpty: [Boolean, false],\n                loadOnFocus: [Boolean, false],\n                selectFirstMatch: [Boolean, true],\n                displayProperty: [String, '']\n            });\n\n            $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);\n\n            this.registerAutocompleteMatch = function() {\n                return {\n                    getOptions: function() {\n                        return $scope.options;\n                    },\n                    getQuery: function() {\n                        return $scope.suggestionList.query;\n                    }\n                };\n            };\n        }],\n        link: function(scope, element, attrs, tagsInputCtrl) {\n            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],\n                suggestionList = scope.suggestionList,\n                tagsInput = tagsInputCtrl.registerAutocomplete(),\n                options = scope.options,\n                events = scope.events,\n                shouldLoadSuggestions;\n\n            options.tagsInput = tagsInput.getOptions();\n\n            shouldLoadSuggestions = function(value) {\n                return value && value.length >= options.minLength || !value && options.loadOnEmpty;\n            };\n\n            scope.addSuggestionByIndex = function(index) {\n                suggestionList.select(index);\n                scope.addSuggestion();\n            };\n\n            scope.addSuggestion = function() {\n                var added = false;\n\n                if (suggestionList.selected) {\n                    tagsInput.addTag(angular.copy(suggestionList.selected));\n                    suggestionList.reset();\n                    tagsInput.focusInput();\n\n                    added = true;\n                }\n                return added;\n            };\n\n            scope.track = function(item) {\n                return item[options.tagsInput.keyProperty || options.tagsInput.displayProperty];\n            };\n\n            tagsInput\n                .on('tag-added invalid-tag input-blur', function() {\n                    suggestionList.reset();\n                })\n                .on('input-change', function(value) {\n                    if (shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                    else {\n                        suggestionList.reset();\n                    }\n                })\n                .on('input-focus', function() {\n                    var value = tagsInput.getCurrentTagText();\n                    if (options.loadOnFocus && shouldLoadSuggestions(value)) {\n                        suggestionList.load(value, tagsInput.getTags());\n                    }\n                })\n                .on('input-keydown', function(event) {\n                    var key = event.keyCode,\n                        handled = false;\n\n                    if (hotkeys.indexOf(key) === -1) {\n                        return;\n                    }\n\n                    if (suggestionList.visible) {\n\n                        if (key === KEYS.down) {\n                            suggestionList.selectNext();\n                            handled = true;\n                        }\n                        else if (key === KEYS.up) {\n                            suggestionList.selectPrior();\n                            handled = true;\n                        }\n                        else if (key === KEYS.escape) {\n                            suggestionList.reset();\n                            handled = true;\n                        }\n                        else if (key === KEYS.enter || key === KEYS.tab) {\n                            handled = scope.addSuggestion();\n                        }\n                    }\n                    else {\n                        if (key === KEYS.down && scope.options.loadOnDownArrow) {\n                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());\n                            handled = true;\n                        }\n                    }\n\n                    if (handled) {\n                        event.preventDefault();\n                        event.stopImmediatePropagation();\n                        return false;\n                    }\n                });\n\n            events.on('suggestion-selected', function(index) {\n                scrollToElement(element, index);\n            });\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiAutocompleteMatch\n * @module ngTagsInput\n *\n * @description\n * Represents an autocomplete match. Used internally by the autoComplete directive.\n */\ntagsInput.directive('tiAutocompleteMatch', [\"$sce\",\"tiUtil\", function($sce, tiUtil) {\n    return {\n        restrict: 'E',\n        require: '^autoComplete',\n        template: '<ng-include src=\"$$template\"></ng-include>',\n        scope: { data: '=' },\n        link: function(scope, element, attrs, autoCompleteCtrl) {\n            var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),\n                options = autoComplete.getOptions();\n\n            scope.$$template = options.template;\n            scope.$index = scope.$parent.$index;\n\n            scope.$highlight = function(text) {\n                if (options.highlightMatchedText) {\n                    text = tiUtil.safeHighlight(text, autoComplete.getQuery());\n                }\n                return $sce.trustAsHtml(text);\n            };\n            scope.$getDisplayText =  function() {\n                return tiUtil.safeToString(scope.data[options.displayProperty || options.tagsInput.displayProperty]);\n            };\n        }\n    };\n}]);\n\n\n/**\n * @ngdoc directive\n * @name tiTranscludeAppend\n * @module ngTagsInput\n *\n * @description\n * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiTranscludeAppend', function() {\n    return function(scope, element, attrs, ctrl, transcludeFn) {\n        transcludeFn(function(clone) {\n            element.append(clone);\n        });\n    };\n});\n\n/**\n * @ngdoc directive\n * @name tiAutosize\n * @module ngTagsInput\n *\n * @description\n * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiAutosize', [\"tagsInputConfig\", function(tagsInputConfig) {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function(scope, element, attrs, ctrl) {\n            var threshold = tagsInputConfig.getTextAutosizeThreshold(),\n                span, resize;\n\n            span = angular.element('<span class=\"input\"></span>');\n            span.css('display', 'none')\n                .css('visibility', 'hidden')\n                .css('width', 'auto')\n                .css('white-space', 'pre');\n\n            element.parent().append(span);\n\n            resize = function(originalValue) {\n                var value = originalValue, width;\n\n                if (angular.isString(value) && value.length === 0) {\n                    value = attrs.placeholder;\n                }\n\n                if (value) {\n                    span.text(value);\n                    span.css('display', '');\n                    width = span.prop('offsetWidth');\n                    span.css('display', 'none');\n                }\n\n                element.css('width', width ? width + threshold + 'px' : '');\n\n                return originalValue;\n            };\n\n            ctrl.$parsers.unshift(resize);\n            ctrl.$formatters.unshift(resize);\n\n            attrs.$observe('placeholder', function(value) {\n                if (!ctrl.$modelValue) {\n                    resize(value);\n                }\n            });\n        }\n    };\n}]);\n\n/**\n * @ngdoc directive\n * @name tiBindAttrs\n * @module ngTagsInput\n *\n * @description\n * Binds attributes to expressions. Used internally by tagsInput directive.\n */\ntagsInput.directive('tiBindAttrs', function() {\n    return function(scope, element, attrs) {\n        scope.$watch(attrs.tiBindAttrs, function(value) {\n            angular.forEach(value, function(value, key) {\n                /**\n                 * blake_r - Added to work around the version of jQuery that\n                 * MAAS currently ships with. Once packaging for jQuery is\n                 * version >1.9 this can be removed.\n                 */\n                if(key === \"type\") {\n                    element[0].type = value;\n                } else {\n                    attrs.$set(key, value);\n                }\n            });\n        }, true);\n    };\n});\n\n/**\n * @ngdoc service\n * @name tagsInputConfig\n * @module ngTagsInput\n *\n * @description\n * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and\n * initialize options from HTML attributes.\n */\ntagsInput.provider('tagsInputConfig', function() {\n    var globalDefaults = {},\n        interpolationStatus = {},\n        autosizeThreshold = 3;\n\n    /**\n     * @ngdoc method\n     * @name setDefaults\n     * @description Sets the default configuration option for a directive.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} defaults Object containing options and their values.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setDefaults = function(directive, defaults) {\n        globalDefaults[directive] = defaults;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setActiveInterpolation\n     * @description Sets active interpolation for a set of options.\n     * @methodOf tagsInputConfig\n     *\n     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.\n     * @param {object} options Object containing which options should have interpolation turned on at all times.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setActiveInterpolation = function(directive, options) {\n        interpolationStatus[directive] = options;\n        return this;\n    };\n\n    /***\n     * @ngdoc method\n     * @name setTextAutosizeThreshold\n     * @description Sets the threshold used by the tagsInput directive to re-size the inner input field element based on its contents.\n     * @methodOf tagsInputConfig\n     *\n     * @param {number} threshold Threshold value, in pixels.\n     *\n     * @returns {object} The service itself for chaining purposes.\n     */\n    this.setTextAutosizeThreshold = function(threshold) {\n        autosizeThreshold = threshold;\n        return this;\n    };\n\n    this.$get = [\"$interpolate\", function($interpolate) {\n        var converters = {};\n        converters[String] = function(value) { return value; };\n        converters[Number] = function(value) { return parseInt(value, 10); };\n        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };\n        converters[RegExp] = function(value) { return new RegExp(value); };\n\n        return {\n            load: function(directive, scope, attrs, options) {\n                var defaultValidator = function() { return true; };\n\n                scope.options = {};\n\n                angular.forEach(options, function(value, key) {\n                    var type, localDefault, validator, converter, getDefault, updateValue;\n\n                    type = value[0];\n                    localDefault = value[1];\n                    validator = value[2] || defaultValidator;\n                    converter = converters[type];\n\n                    getDefault = function() {\n                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];\n                        return angular.isDefined(globalValue) ? globalValue : localDefault;\n                    };\n\n                    updateValue = function(value) {\n                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();\n                    };\n\n                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {\n                        attrs.$observe(key, function(value) {\n                            updateValue(value);\n                            scope.events.trigger('option-change', { name: key, newValue: value });\n                        });\n                    }\n                    else {\n                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));\n                    }\n                });\n            },\n            getTextAutosizeThreshold: function() {\n                return autosizeThreshold;\n            }\n        };\n    }];\n});\n\n\n/***\n * @ngdoc factory\n * @name tiUtil\n * @module ngTagsInput\n *\n * @description\n * Helper methods used internally by the directive. Should not be called directly from user code.\n */\ntagsInput.factory('tiUtil', [\"$timeout\", function($timeout) {\n    var self = {};\n\n    self.debounce = function(fn, delay) {\n        var timeoutId;\n        return function() {\n            var args = arguments;\n            $timeout.cancel(timeoutId);\n            timeoutId = $timeout(function() { fn.apply(null, args); }, delay);\n        };\n    };\n\n    self.makeObjectArray = function(array, key) {\n        array = array || [];\n        if (array.length > 0 && !angular.isObject(array[0])) {\n            array.forEach(function(item, index) {\n                array[index] = {};\n                array[index][key] = item;\n            });\n        }\n        return array;\n    };\n\n    self.findInObjectArray = function(array, obj, key, comparer) {\n        var item = null;\n        comparer = comparer || self.defaultComparer;\n\n        array.some(function(element) {\n            if (comparer(element[key], obj[key])) {\n                item = element;\n                return true;\n            }\n        });\n\n        return item;\n    };\n\n    self.defaultComparer = function(a, b) {\n        // I'm aware of the internationalization issues regarding toLowerCase()\n        // but I couldn't come up with a better solution right now\n        return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();\n    };\n\n    self.safeHighlight = function(str, value) {\n        if (!value) {\n            return str;\n        }\n\n        function escapeRegexChars(str) {\n            return str.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n        }\n\n        str = self.encodeHTML(str);\n        value = self.encodeHTML(value);\n\n        var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');\n        return str.replace(expression, function(match) {\n            return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;\n        });\n    };\n\n    self.safeToString = function(value) {\n        return angular.isUndefined(value) || value == null ? '' : value.toString().trim();\n    };\n\n    self.encodeHTML = function(value) {\n        return self.safeToString(value)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    };\n\n    self.handleUndefinedResult = function(fn, valueIfUndefined) {\n        return function() {\n            var result = fn.apply(null, arguments);\n            return angular.isUndefined(result) ? valueIfUndefined : result;\n        };\n    };\n\n    self.replaceSpacesWithDashes = function(str) {\n        return self.safeToString(str).replace(/\\s/g, '-');\n    };\n\n    self.simplePubSub = function() {\n        var events = {};\n        return {\n            on: function(names, handler) {\n                names.split(' ').forEach(function(name) {\n                    if (!events[name]) {\n                        events[name] = [];\n                    }\n                    events[name].push(handler);\n                });\n                return this;\n            },\n            trigger: function(name, args) {\n                var handlers = events[name] || [];\n                handlers.every(function(handler) {\n                    return self.handleUndefinedResult(handler, true)(args);\n                });\n                return this;\n            }\n        };\n    };\n\n    return self;\n}]);\n\n/* HTML templates */\ntagsInput.run([\"$templateCache\", function($templateCache) {\n    $templateCache.put('ngTagsInput/tags-input.html',\n    \"<div class=\\\"host\\\" tabindex=\\\"-1\\\" data-ng-click=\\\"eventHandlers.host.click()\\\" ti-transclude-append=\\\"\\\"><div class=\\\"tags\\\" data-ng-class=\\\"{focused: hasFocus}\\\"><ul class=\\\"tag-list\\\"><li class=\\\"tag-item\\\" data-ng-repeat=\\\"tag in tagList.items track by track(tag)\\\" data-ng-class=\\\"{ selected: tag == tagList.selected }\\\"><ti-tag-item data=\\\"tag\\\"></ti-tag-item></li></ul><input class=\\\"input u-no-margin--top\\\" autocomplete=\\\"off\\\" data-ng-model=\\\"newTag.text\\\" data-ng-change=\\\"eventHandlers.input.change(newTag.text)\\\" data-ng-keydown=\\\"eventHandlers.input.keydown($event)\\\" data-ng-focus=\\\"eventHandlers.input.focus($event)\\\" data-ng-blur=\\\"eventHandlers.input.blur($event)\\\" data-ng-paste=\\\"eventHandlers.input.paste($event)\\\" data-ng-trim=\\\"false\\\" data-ng-class=\\\"{'invalid-tag': newTag.invalid}\\\" data-ng-disabled=\\\"disabled\\\" ti-bind-attrs=\\\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\\\" ti-autosize=\\\"\\\"></div></div>\"\n  );\n\n  $templateCache.put('ngTagsInput/tag-item.html',\n    \"<span ng-bind=\\\"$getDisplayText()\\\"></span> <a class=\\\"p-icon--close\\\" data-ng-click=\\\"$removeTag()\\\" data-ng-bind=\\\"$$removeTagSymbol\\\">Remove tag</a>\"\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete.html',\n    \"<div class=\\\"autocomplete\\\" data-ng-if=\\\"suggestionList.visible\\\"><ul class=\\\"p-list suggestion-list\\\"><li class=\\\"suggestion-item\\\" data-ng-repeat=\\\"item in suggestionList.items track by track(item)\\\" data-ng-class=\\\"{selected: item == suggestionList.selected}\\\" data-ng-click=\\\"addSuggestionByIndex($index)\\\" data-ng-mouseenter=\\\"suggestionList.select($index)\\\"><ti-autocomplete-match data=\\\"item\\\"></ti-autocomplete-match></li></ul></div>\"\n  );\n\n  $templateCache.put('ngTagsInput/auto-complete-match.html',\n    \"<span data-ng-bind-html=\\\"$highlight($getDisplayText())\\\"></span>\"\n  );\n}]);\n\n}());\n","/**\n * ngSticky - https://github.com/d-oliveros/ngSticky\n *\n * A simple, pure javascript (No jQuery required!) AngularJS directive\n * to make elements stick when scrolling down.\n *\n * Credits: https://github.com/d-oliveros/ngSticky/graphs/contributors\n */\n(function() {\n  'use strict';\n\n  var module = angular.module('sticky', []);\n\n  /**\n   * Directive: sticky\n   */\n  module.directive('sticky', ['$window', '$timeout', function($window, $timeout) {\n      return {\n        restrict: 'A', // this directive can only be used as an attribute.\n        scope: {\n          disabled: '=disabledSticky'\n        },\n        link: function linkFn($scope, $elem, $attrs) {\n\n          // Initial scope\n          var scrollableNodeTagName = 'sticky-scroll';\n          var initialPosition = $elem.css('position');\n          var initialStyle = $elem.attr('style') || '';\n          var stickyBottomLine = 0;\n          var isSticking = false;\n          var onStickyHeighUnbind;\n          var originalInitialCSS;\n          var originalOffset;\n          var placeholder;\n          var stickyLine;\n          var initialCSS;\n\n          // Optional Classes\n          var stickyClass = $attrs.stickyClass || '';\n          var unstickyClass = $attrs.unstickyClass || '';\n          var bodyClass = $attrs.bodyClass || '';\n          var bottomClass = $attrs.bottomClass || '';\n\n          // Find scrollbar\n          var scrollbar = deriveScrollingViewport ($elem);\n\n          // Define elements\n          var windowElement = angular.element($window);\n          var scrollbarElement = angular.element(scrollbar);\n          var $body = angular.element(document.body);\n\n          // Resize callback\n          var $onResize = function () {\n            if ($scope.$root && !$scope.$root.$$phase) {\n              $scope.$apply(onResize);\n            } else {\n              onResize();\n            }\n          };\n\n          // Define options\n          var usePlaceholder = ($attrs.usePlaceholder !== 'false');\n          var anchor = $attrs.anchor === 'bottom' ? 'bottom' : 'top';\n          var confine = ($attrs.confine === 'true');\n\n          // flag: can react to recalculating the initial CSS dimensions later\n          // as link executes prematurely. defaults to immediate checking\n          var isStickyLayoutDeferred = $attrs.isStickyLayoutDeferred !== undefined\n            ? ($attrs.isStickyLayoutDeferred === 'true')\n            : false;\n\n          // flag: is sticky content constantly observed for changes.\n          // Should be true if content uses ngBind to show text\n          // that may vary in size over time\n          var isStickyLayoutWatched = $attrs.isStickyLayoutWatched !== undefined\n          ? ($attrs.isStickyLayoutWatched === 'true')\n          : true;\n\n\n          var offset = $attrs.offset\n            ? parseInt ($attrs.offset.replace(/px;?/, ''))\n            : 0;\n\n          /**\n           * Trigger to initialize the sticky\n           * Because of the `timeout()` method for the call of\n           * @type {Boolean}\n           */\n          var shouldInitialize = true;\n\n          /**\n           * Initialize Sticky\n           */\n          function initSticky() {\n\n            if (shouldInitialize) {\n\n              // Listeners\n              scrollbarElement.on('scroll', checkIfShouldStick);\n              windowElement.on('resize', $onResize);\n\n              memorizeDimensions(); // remember sticky's layout dimensions\n\n              // Setup watcher on digest and change\n              $scope.$watch(onDigest, onChange);\n\n              // Clean up\n              $scope.$on('$destroy', onDestroy);\n              shouldInitialize = false;\n            }\n          };\n\n          /**\n           * need to recall sticky's DOM attributes (make sure layout has occured)\n           */\n          function memorizeDimensions() {\n            // immediate assignment, but there is the potential for wrong values if content not ready\n            initialCSS = $scope.getInitialDimensions();\n\n            // option to calculate the dimensions when layout is 'ready'\n            if (isStickyLayoutDeferred) {\n\n              // logic: when this directive link() runs before the content has had a chance to layout on browser, height could be 0\n              if (!$elem[0].getBoundingClientRect().height) {\n\n                onStickyHeighUnbind = $scope.$watch(\n                    function() {\n                      return $elem.height();\n                    },\n\n                    // state change: sticky content's height set\n                    function onStickyContentLayoutInitialHeightSet(newValue, oldValue) {\n                      if (newValue > 0) {\n                        // now can memorize\n                        initialCSS = $scope.getInitialDimensions();\n\n                        if (!isStickyLayoutWatched) {\n                          // preference was to do just a one-time async watch on the sticky's content; now stop watching\n                          onStickyHeighUnbind();\n                        }\n                      }\n                    }\n               );\n              }\n            }\n          }\n\n          /**\n           * Determine if the element should be sticking or not.\n           */\n          var checkIfShouldStick = function() {\n            if ($scope.disabled === true || mediaQueryMatches()) {\n              if (isSticking) unStickElement();\n              return false;\n            }\n\n            // What's the document client top for?\n            var scrollbarPosition = scrollbarYPos();\n            var shouldStick;\n\n            if (anchor === 'top') {\n              if (confine === true) {\n                shouldStick = scrollbarPosition > stickyLine && scrollbarPosition <= stickyBottomLine;\n              } else {\n                shouldStick = scrollbarPosition > stickyLine;\n              }\n            } else {\n              shouldStick = scrollbarPosition <= stickyLine;\n            }\n\n            // Switch the sticky mode if the element crosses the sticky line\n            // $attrs.stickLimit - when it's equal to true it enables the user\n            // to turn off the sticky function when the elem height is\n            // bigger then the viewport\n            var closestLine = getClosest (scrollbarPosition, stickyLine, stickyBottomLine);\n\n            if (shouldStick && !shouldStickWithLimit ($attrs.stickLimit) && !isSticking) {\n              stickElement (closestLine);\n            } else if (!shouldStick && isSticking) {\n              unStickElement(closestLine, scrollbarPosition);\n            } else if (confine && !shouldStick) {\n              // If we are confined to the parent, refresh, and past the stickyBottomLine\n              // We should 'remember' the original offset and unstick the element which places it at the stickyBottomLine\n              originalOffset = elementsOffsetFromTop ($elem[0]);\n              unStickElement (closestLine, scrollbarPosition);\n            }\n          };\n\n          /**\n           * determine the respective node that handles scrolling, defaulting to browser window\n           */\n          function deriveScrollingViewport(stickyNode) {\n            // derive relevant scrolling by ascending the DOM tree\n            var match =findAncestorTag (scrollableNodeTagName, stickyNode);\n            return (match.length === 1) ? match[0] : $window;\n          }\n\n          /**\n           * since jqLite lacks closest(), this is a pseudo emulator (by tag name)\n           */\n          function findAncestorTag(tag, context) {\n            var m = []; // nodelist container\n            var n = context.parent(); // starting point\n            var p;\n\n            do {\n              var node = n[0]; // break out of jqLite\n              // limit DOM territory\n              if (node.nodeType !== 1) {\n                break;\n              }\n\n              // success\n              if (node.tagName.toUpperCase() === tag.toUpperCase()) {\n                return n;\n              }\n\n              p = n.parent();\n              n = p; // set to parent\n            } while (p.length !== 0);\n\n            return m; // empty set\n          }\n\n          /**\n           * Seems to be undocumented functionality\n           */\n          function shouldStickWithLimit(shouldApplyWithLimit) {\n            return shouldApplyWithLimit === 'true'\n              ? ($window.innerHeight - ($elem[0].offsetHeight + parseInt(offset)) < 0)\n              : false;\n          }\n\n          /**\n           * Finds the closest value from a set of numbers in an array.\n           */\n          function getClosest(scrollTop, stickyLine, stickyBottomLine) {\n            var closest = 'top';\n            var topDistance = Math.abs(scrollTop - stickyLine);\n            var bottomDistance = Math.abs(scrollTop - stickyBottomLine);\n\n            if (topDistance > bottomDistance) {\n              closest = 'bottom';\n            }\n\n            return closest;\n          }\n\n          /**\n           * Unsticks the element\n           */\n          function unStickElement(fromDirection) {\n            if (initialStyle) {\n              $elem.attr('style', initialStyle);\n            }\n            isSticking = false;\n\n            initialCSS.width = $scope.getInitialDimensions().width;\n\n            $body.removeClass(bodyClass);\n            $elem.removeClass(stickyClass);\n            $elem.addClass(unstickyClass);\n\n            if (fromDirection === 'top') {\n              $elem.removeClass(bottomClass);\n\n              $elem\n                .css('z-index', 10)\n                .css('width', initialCSS.width)\n                .css('top', initialCSS.top)\n                .css('position', initialCSS.position)\n                .css('left', initialCSS.cssLeft)\n                .css('margin-top', initialCSS.marginTop);\n            } else if (fromDirection === 'bottom' && confine === true) {\n              $elem.addClass(bottomClass);\n\n              // It's possible to page down page and skip the 'stickElement'.\n              // In that case we should create a placeholder so the offsets don't get off.\n              createPlaceholder();\n\n              $elem\n                .css('z-index', 10)\n                .css('width', initialCSS.width)\n                .css('top', '')\n                .css('bottom', 0)\n                .css('position', 'absolute')\n                .css('left', initialCSS.cssLeft)\n                .css('margin-top', initialCSS.marginTop)\n                .css('margin-bottom', initialCSS.marginBottom);\n            }\n\n            if (placeholder && fromDirection === anchor) {\n              placeholder.remove();\n            }\n          }\n\n          /**\n           * Sticks the element\n           */\n          function stickElement(closestLine) {\n            // Set sticky state\n            isSticking = true;\n            $timeout(function() {\n              initialCSS.offsetWidth = $elem[0].offsetWidth;\n            }, 0);\n            $body.addClass(bodyClass);\n            $elem.removeClass(unstickyClass);\n            $elem.removeClass(bottomClass);\n            $elem.addClass(stickyClass);\n\n            createPlaceholder();\n\n            $elem\n              .css('z-index', '10')\n              .css('width', $elem[0].offsetWidth + 'px')\n              .css('position', 'fixed')\n              .css('left', $elem.css('left').replace('px', '') + 'px')\n              .css(anchor, (offset + elementsOffsetFromTop (scrollbar)) + 'px')\n              .css('margin-top', 0);\n\n            if (anchor === 'bottom') {\n              $elem.css('margin-bottom', 0);\n            }\n          }\n\n          /**\n           * Clean up directive\n           */\n          var onDestroy = function() {\n            scrollbarElement.off('scroll', checkIfShouldStick);\n            windowElement.off('resize', $onResize);\n\n            $onResize = null;\n\n            $body.removeClass(bodyClass);\n\n            if (placeholder) {\n              placeholder.remove();\n            }\n          };\n\n          /**\n           * Updates on resize.\n           */\n          function onResize() {\n            unStickElement (anchor);\n            checkIfShouldStick();\n          }\n\n          /**\n           * Triggered on load / digest cycle\n           * return `0` if the DOM element is hidden\n           */\n          var onDigest = function() {\n            if ($scope.disabled === true) {\n              return unStickElement();\n            }\n            var offsetFromTop = elementsOffsetFromTop ($elem[0]);\n            if (offsetFromTop === 0) {\n              return offsetFromTop;\n            }\n            if (anchor === 'top') {\n              return (originalOffset || offsetFromTop) - elementsOffsetFromTop (scrollbar) + scrollbarYPos();\n            } else {\n              return offsetFromTop - scrollbarHeight() + $elem[0].offsetHeight + scrollbarYPos();\n            }\n          };\n\n          /**\n           * Triggered on change\n           */\n          var onChange = function (newVal, oldVal) {\n\n            /**\n             * Indicate if the DOM element is showed, or not\n             * @type {boolean}\n             */\n            var elemIsShowed = !!newVal;\n\n            /**\n             * Indicate if the DOM element was showed, or not\n             * @type {boolean}\n             */\n            var elemWasHidden = !oldVal;\n            var valChange = (newVal !== oldVal || typeof stickyLine === 'undefined');\n            var notSticking = (!isSticking && !isBottomedOut());\n\n            if (valChange && notSticking && newVal > 0 && elemIsShowed) {\n              stickyLine = newVal - offset;\n              //Update dimensions of sticky element when is showed\n              if (elemIsShowed && elemWasHidden) {\n                $scope.updateStickyContentUpdateDimensions($elem[0].offsetWidth, $elem[0].offsetHeight);\n              }\n              // IF the sticky is confined, we want to make sure the parent is relatively positioned,\n              // otherwise it won't bottom out properly\n              if (confine) {\n                $elem.parent().css({\n                  'position': 'relative'\n                });\n              }\n\n              // Get Parent height, so we know when to bottom out for confined stickies\n              var parent = $elem.parent()[0];\n\n              // Offset parent height by the elements height, if we're not using a placeholder\n              var parentHeight = parseInt (parent.offsetHeight) - (usePlaceholder ? 0 : $elem[0].offsetHeight);\n\n              // and now lets ensure we adhere to the bottom margins\n              // TODO: make this an attribute? Maybe like ignore-margin?\n              var marginBottom = parseInt ($elem.css('margin-bottom').replace(/px;?/, '')) || 0;\n\n              // specify the bottom out line for the sticky to unstick\n              var elementsDistanceFromTop = elementsOffsetFromTop ($elem[0]);\n              var parentsDistanceFromTop = elementsOffsetFromTop (parent)\n              var scrollbarDistanceFromTop = elementsOffsetFromTop (scrollbar);\n\n              var elementsDistanceFromScrollbarStart = elementsDistanceFromTop - scrollbarDistanceFromTop;\n              var elementsDistanceFromBottom = parentsDistanceFromTop + parentHeight - elementsDistanceFromTop;\n\n              stickyBottomLine = elementsDistanceFromScrollbarStart\n                + elementsDistanceFromBottom\n                - $elem[0].offsetHeight\n                - marginBottom\n                - offset\n                + +scrollbarYPos();\n\n              checkIfShouldStick();\n            }\n          };\n\n          /**\n           * Helper Functions\n           */\n\n          /**\n           * Create a placeholder\n           */\n          function createPlaceholder() {\n            if (usePlaceholder) {\n              // Remove the previous placeholder\n              if (placeholder) {\n                placeholder.remove();\n              }\n\n              placeholder = angular.element('<div>');\n              var elementsHeight = $elem[0].offsetHeight;\n              var computedStyle = $elem[0].currentStyle || window.getComputedStyle($elem[0]);\n              elementsHeight += parseInt(computedStyle.marginTop, 10);\n              elementsHeight += parseInt(computedStyle.marginBottom, 10);\n              elementsHeight += parseInt(computedStyle.borderTopWidth, 10);\n              elementsHeight += parseInt(computedStyle.borderBottomWidth, 10);\n              placeholder.css('height', $elem[0].offsetHeight + 'px');\n\n              $elem.after(placeholder);\n            }\n          }\n\n          /**\n           * Are we bottomed out of the parent element?\n           */\n          function isBottomedOut() {\n            if (confine && scrollbarYPos() > stickyBottomLine) {\n              return true;\n            }\n\n            return false;\n          }\n\n          /**\n           * Fetch top offset of element\n           */\n          function elementsOffsetFromTop(element) {\n            var offset = 0;\n\n            if (element.getBoundingClientRect) {\n              offset = element.getBoundingClientRect().top;\n            }\n\n            return offset;\n          }\n\n          /**\n           * Retrieves top scroll distance\n           */\n          function scrollbarYPos() {\n            var position;\n\n            if (typeof scrollbar.scrollTop !== 'undefined') {\n              position = scrollbar.scrollTop;\n            } else if (typeof scrollbar.pageYOffset !== 'undefined') {\n              position = scrollbar.pageYOffset;\n            } else {\n              position = document.documentElement.scrollTop;\n            }\n\n            return position;\n          }\n\n          /**\n           * Determine scrollbar's height\n           */\n          function scrollbarHeight() {\n            var height;\n\n            if (scrollbarElement[0] instanceof HTMLElement) {\n              // isn't bounding client rect cleaner than insane regex mess?\n              height = $window.getComputedStyle(scrollbarElement[0], null)\n                  .getPropertyValue('height')\n                  .replace(/px;?/, '');\n            } else {\n              height = $window.innerHeight;\n            }\n\n            return parseInt (height) || 0;\n          }\n\n          /**\n           * Checks if the media matches\n           */\n          function mediaQueryMatches() {\n            var mediaQuery = $attrs.mediaQuery || false;\n            var matchMedia = $window.matchMedia;\n\n            return mediaQuery && !(matchMedia ('(' + mediaQuery + ')').matches || matchMedia (mediaQuery).matches);\n          }\n\n          /**\n           * Get more accurate CSS values\n           */\n          function getCSS($el, prop){\n            var el = $el[0],\n                computed = window.getComputedStyle(el),\n                prevDisplay = computed.display,\n                val;\n\n            // hide the element so that we can get original css\n            // values instead of computed values\n            el.style.display = \"none\";\n\n            // NOTE - computed style declaration object is a reference\n            // to the element's CSSStyleDeclaration, so it will always\n            // reflect the current style of the element\n            val = computed[prop];\n\n            // restore previous display value\n            el.style.display = prevDisplay;\n\n            return val;\n          }\n\n          // public accessors for the controller to hitch into. Helps with external API access\n          $scope.getElement = function() { return $elem; };\n          $scope.getScrollbar = function() { return scrollbar; };\n          $scope.getInitialCSS = function() { return initialCSS; };\n          $scope.getAnchor = function() { return anchor; };\n          $scope.isSticking = function() { return isSticking; };\n          $scope.getOriginalInitialCSS = function() { return originalInitialCSS; };\n          // pass through aliases\n          $scope.processUnStickElement = function(anchor) { unStickElement(anchor)};\n          $scope.processCheckIfShouldStick =function() { checkIfShouldStick(); };\n\n          /**\n           * set the dimensions for the defaults of the content block occupied by the sticky element\n           */\n          $scope.getInitialDimensions = function() {\n            return {\n              zIndex: $elem.css('z-index'),\n              top: $elem.css('top'),\n              position: initialPosition, // revert to true initial state\n              marginTop: $elem.css('margin-top'),\n              marginBottom: $elem.css('margin-bottom'),\n              cssLeft: getCSS($elem, 'left'),\n              width: $elem[0].offsetWidth,\n              height: $elem.css('height')\n            };\n          };\n\n          /**\n           * only change content box dimensions\n           */\n          $scope.updateStickyContentUpdateDimensions = function(width, height) {\n            if (width && height) {\n              initSticky();\n              initialCSS.width = width + 'px';\n              initialCSS.height = height + 'px';\n            }\n          };\n\n          // ----------- configuration -----------\n\n          $timeout(function() {\n            originalInitialCSS = $scope.getInitialDimensions(); // preserve a copy\n            // Init the directive\n            initSticky();\n          },0);\n        },\n\n        /**\n         * +++++++++ public APIs+++++++++++++\n         */\n        controller: ['$scope', '$window', function($scope, $window) {\n\n          /**\n           * integration method allows for an outside client to reset the pinned state back to unpinned.\n           * Useful for when refreshing the scrollable DIV content completely\n           * if newWidth and newHeight integer values are not supplied then function will make a best guess\n           */\n          this.resetLayout = function(newWidth, newHeight) {\n\n            var scrollbar = $scope.getScrollbar(),\n                initialCSS = $scope.getInitialCSS(),\n                anchor = $scope.getAnchor();\n\n            function _resetScrollPosition() {\n\n              // reset means content is scrolled to anchor position\n              if (anchor === 'top') {\n                // window based scroller\n                if (scrollbar === $window) {\n                  $window.scrollTo(0, 0);\n                  // DIV based sticky scroller\n                } else {\n                  if (scrollbar.scrollTop > 0) {\n                    scrollbar.scrollTop = 0;\n                  }\n                }\n              }\n              // todo: need bottom use case\n            }\n\n            // only if pinned, force unpinning, otherwise height is inadvertently reset to 0\n            if ($scope.isSticking()) {\n              $scope.processUnStickElement (anchor);\n              $scope.processCheckIfShouldStick();\n            }\n            // remove layout-affecting attribures that were modified by this sticky\n            $scope.getElement().css({ 'width': '', 'height': '', 'position': '', 'top': '', zIndex: '' });\n            // model resets\n            initialCSS.position = $scope.getOriginalInitialCSS().position; // revert to original state\n            delete initialCSS.offsetWidth; // stickElement affected\n\n            // use this directive element's as default, if no measurements passed in\n            if (newWidth === undefined && newHeight === undefined) {\n              var e_bcr = $scope.getElement()[0].getBoundingClientRect();\n              newWidth = e_bcr.width;\n              newHeight = e_bcr.height;\n            }\n\n            // update model with new dimensions (if supplied from client's own measurement)\n            $scope.updateStickyContentUpdateDimensions(newWidth, newHeight); // update layout dimensions only\n\n            _resetScrollPosition();\n          };\n\n          /**\n           * return a reference to the scrolling element (window or DIV with overflow)\n           */\n          this.getScrollbar = function() {\n            return $scope.getScrollbar();\n          };\n        }]\n      };\n    }]\n );\n\n  // Shiv: matchMedia\n  window.matchMedia = window.matchMedia || (function() {\n      var warning = 'angular-sticky: This browser does not support ' +\n        'matchMedia, therefore the minWidth option will not work on ' +\n        'this browser. Polyfill matchMedia to fix this issue.';\n\n      if (window.console && console.warn) {\n        console.warn(warning);\n      }\n\n      return function() {\n        return {\n          matches: true\n        };\n      };\n    }());\n}());\n","/**\n * ngSticky - https://github.com/d-oliveros/ngSticky\n *\n * A simple, pure javascript (No jQuery required!) AngularJS directive\n * to make elements stick when scrolling down.\n *\n * Credits: https://github.com/d-oliveros/ngSticky/graphs/contributors\n */\n(function() {\n  'use strict';\n\n  var module = angular.module('sticky', []);\n\n  /**\n   * Directive: sticky\n   */\n  module.directive('sticky', ['$window', '$timeout', function($window, $timeout) {\n      return {\n        restrict: 'A', // this directive can only be used as an attribute.\n        scope: {\n          disabled: '=disabledSticky'\n        },\n        link: function linkFn($scope, $elem, $attrs) {\n\n          // Initial scope\n          var scrollableNodeTagName = 'sticky-scroll';\n          var initialPosition = $elem.css('position');\n          var initialStyle = $elem.attr('style') || '';\n          var stickyBottomLine = 0;\n          var isSticking = false;\n          var onStickyHeighUnbind;\n          var originalInitialCSS;\n          var originalOffset;\n          var placeholder;\n          var stickyLine;\n          var initialCSS;\n\n          // Optional Classes\n          var stickyClass = $attrs.stickyClass || '';\n          var unstickyClass = $attrs.unstickyClass || '';\n          var bodyClass = $attrs.bodyClass || '';\n          var bottomClass = $attrs.bottomClass || '';\n\n          // Find scrollbar\n          var scrollbar = deriveScrollingViewport ($elem);\n\n          // Define elements\n          var windowElement = angular.element($window);\n          var scrollbarElement = angular.element(scrollbar);\n          var $body = angular.element(document.body);\n\n          // Resize callback\n          var $onResize = function () {\n            if ($scope.$root && !$scope.$root.$$phase) {\n              $scope.$apply(onResize);\n            } else {\n              onResize();\n            }\n          };\n\n          // Define options\n          var usePlaceholder = ($attrs.usePlaceholder !== 'false');\n          var anchor = $attrs.anchor === 'bottom' ? 'bottom' : 'top';\n          var confine = ($attrs.confine === 'true');\n\n          // flag: can react to recalculating the initial CSS dimensions later\n          // as link executes prematurely. defaults to immediate checking\n          var isStickyLayoutDeferred = $attrs.isStickyLayoutDeferred !== undefined\n            ? ($attrs.isStickyLayoutDeferred === 'true')\n            : false;\n\n          // flag: is sticky content constantly observed for changes.\n          // Should be true if content uses ngBind to show text\n          // that may vary in size over time\n          var isStickyLayoutWatched = $attrs.isStickyLayoutWatched !== undefined\n          ? ($attrs.isStickyLayoutWatched === 'true')\n          : true;\n\n\n          var offset = $attrs.offset\n            ? parseInt ($attrs.offset.replace(/px;?/, ''))\n            : 0;\n\n          /**\n           * Trigger to initialize the sticky\n           * Because of the `timeout()` method for the call of\n           * @type {Boolean}\n           */\n          var shouldInitialize = true;\n\n          /**\n           * Initialize Sticky\n           */\n          function initSticky() {\n\n            if (shouldInitialize) {\n\n              // Listeners\n              scrollbarElement.on('scroll', checkIfShouldStick);\n              windowElement.on('resize', $onResize);\n\n              memorizeDimensions(); // remember sticky's layout dimensions\n\n              // Setup watcher on digest and change\n              $scope.$watch(onDigest, onChange);\n\n              // Clean up\n              $scope.$on('$destroy', onDestroy);\n              shouldInitialize = false;\n            }\n          };\n\n          /**\n           * need to recall sticky's DOM attributes (make sure layout has occured)\n           */\n          function memorizeDimensions() {\n            // immediate assignment, but there is the potential for wrong values if content not ready\n            initialCSS = $scope.getInitialDimensions();\n\n            // option to calculate the dimensions when layout is 'ready'\n            if (isStickyLayoutDeferred) {\n\n              // logic: when this directive link() runs before the content has had a chance to layout on browser, height could be 0\n              if (!$elem[0].getBoundingClientRect().height) {\n\n                onStickyHeighUnbind = $scope.$watch(\n                    function() {\n                      return $elem.height();\n                    },\n\n                    // state change: sticky content's height set\n                    function onStickyContentLayoutInitialHeightSet(newValue, oldValue) {\n                      if (newValue > 0) {\n                        // now can memorize\n                        initialCSS = $scope.getInitialDimensions();\n\n                        if (!isStickyLayoutWatched) {\n                          // preference was to do just a one-time async watch on the sticky's content; now stop watching\n                          onStickyHeighUnbind();\n                        }\n                      }\n                    }\n               );\n              }\n            }\n          }\n\n          /**\n           * Determine if the element should be sticking or not.\n           */\n          var checkIfShouldStick = function() {\n            if ($scope.disabled === true || mediaQueryMatches()) {\n              if (isSticking) unStickElement();\n              return false;\n            }\n\n            // What's the document client top for?\n            var scrollbarPosition = scrollbarYPos();\n            var shouldStick;\n\n            if (anchor === 'top') {\n              if (confine === true) {\n                shouldStick = scrollbarPosition > stickyLine && scrollbarPosition <= stickyBottomLine;\n              } else {\n                shouldStick = scrollbarPosition > stickyLine;\n              }\n            } else {\n              shouldStick = scrollbarPosition <= stickyLine;\n            }\n\n            // Switch the sticky mode if the element crosses the sticky line\n            // $attrs.stickLimit - when it's equal to true it enables the user\n            // to turn off the sticky function when the elem height is\n            // bigger then the viewport\n            var closestLine = getClosest (scrollbarPosition, stickyLine, stickyBottomLine);\n\n            if (shouldStick && !shouldStickWithLimit ($attrs.stickLimit) && !isSticking) {\n              stickElement (closestLine);\n            } else if (!shouldStick && isSticking) {\n              unStickElement(closestLine, scrollbarPosition);\n            } else if (confine && !shouldStick) {\n              // If we are confined to the parent, refresh, and past the stickyBottomLine\n              // We should 'remember' the original offset and unstick the element which places it at the stickyBottomLine\n              originalOffset = elementsOffsetFromTop ($elem[0]);\n              unStickElement (closestLine, scrollbarPosition);\n            }\n          };\n\n          /**\n           * determine the respective node that handles scrolling, defaulting to browser window\n           */\n          function deriveScrollingViewport(stickyNode) {\n            // derive relevant scrolling by ascending the DOM tree\n            var match =findAncestorTag (scrollableNodeTagName, stickyNode);\n            return (match.length === 1) ? match[0] : $window;\n          }\n\n          /**\n           * since jqLite lacks closest(), this is a pseudo emulator (by tag name)\n           */\n          function findAncestorTag(tag, context) {\n            var m = []; // nodelist container\n            var n = context.parent(); // starting point\n            var p;\n\n            do {\n              var node = n[0]; // break out of jqLite\n              // limit DOM territory\n              if (node.nodeType !== 1) {\n                break;\n              }\n\n              // success\n              if (node.tagName.toUpperCase() === tag.toUpperCase()) {\n                return n;\n              }\n\n              p = n.parent();\n              n = p; // set to parent\n            } while (p.length !== 0);\n\n            return m; // empty set\n          }\n\n          /**\n           * Seems to be undocumented functionality\n           */\n          function shouldStickWithLimit(shouldApplyWithLimit) {\n            return shouldApplyWithLimit === 'true'\n              ? ($window.innerHeight - ($elem[0].offsetHeight + parseInt(offset)) < 0)\n              : false;\n          }\n\n          /**\n           * Finds the closest value from a set of numbers in an array.\n           */\n          function getClosest(scrollTop, stickyLine, stickyBottomLine) {\n            var closest = 'top';\n            var topDistance = Math.abs(scrollTop - stickyLine);\n            var bottomDistance = Math.abs(scrollTop - stickyBottomLine);\n\n            if (topDistance > bottomDistance) {\n              closest = 'bottom';\n            }\n\n            return closest;\n          }\n\n          /**\n           * Unsticks the element\n           */\n          function unStickElement(fromDirection) {\n            if (initialStyle) {\n              $elem.attr('style', initialStyle);\n            }\n            isSticking = false;\n\n            initialCSS.width = $scope.getInitialDimensions().width;\n\n            $body.removeClass(bodyClass);\n            $elem.removeClass(stickyClass);\n            $elem.addClass(unstickyClass);\n\n            if (fromDirection === 'top') {\n              $elem.removeClass(bottomClass);\n\n              $elem\n                .css('z-index', 10)\n                .css('width', initialCSS.width)\n                .css('top', initialCSS.top)\n                .css('position', initialCSS.position)\n                .css('left', initialCSS.cssLeft)\n                .css('margin-top', initialCSS.marginTop)\n                .css('height', initialCSS.height);\n            } else if (fromDirection === 'bottom' && confine === true) {\n              $elem.addClass(bottomClass);\n\n              // It's possible to page down page and skip the 'stickElement'.\n              // In that case we should create a placeholder so the offsets don't get off.\n              createPlaceholder();\n\n              $elem\n                .css('z-index', 10)\n                .css('width', initialCSS.width)\n                .css('top', '')\n                .css('bottom', 0)\n                .css('position', 'absolute')\n                .css('left', initialCSS.cssLeft)\n                .css('margin-top', initialCSS.marginTop)\n                .css('margin-bottom', initialCSS.marginBottom)\n                .css('height', initialCSS.height);\n            }\n\n            if (placeholder && fromDirection === anchor) {\n              placeholder.remove();\n            }\n          }\n\n          /**\n           * Sticks the element\n           */\n          function stickElement(closestLine) {\n            // Set sticky state\n            isSticking = true;\n            $timeout(function() {\n              initialCSS.offsetWidth = $elem[0].offsetWidth;\n            }, 0);\n            $body.addClass(bodyClass);\n            $elem.removeClass(unstickyClass);\n            $elem.removeClass(bottomClass);\n            $elem.addClass(stickyClass);\n\n            createPlaceholder();\n\n            $elem\n              .css('z-index', '10')\n              .css('width', $elem[0].offsetWidth + 'px')\n              .css('position', 'fixed')\n              .css('left', $elem.css('left').replace('px', '') + 'px')\n              .css(anchor, (offset + elementsOffsetFromTop (scrollbar)) + 'px')\n              .css('margin-top', 0);\n\n            if (anchor === 'bottom') {\n              $elem.css('margin-bottom', 0);\n            }\n          }\n\n          /**\n           * Clean up directive\n           */\n          var onDestroy = function() {\n            scrollbarElement.off('scroll', checkIfShouldStick);\n            windowElement.off('resize', $onResize);\n\n            $onResize = null;\n\n            $body.removeClass(bodyClass);\n\n            if (placeholder) {\n              placeholder.remove();\n            }\n          };\n\n          /**\n           * Updates on resize.\n           */\n          function onResize() {\n            unStickElement (anchor);\n            checkIfShouldStick();\n          }\n\n          /**\n           * Triggered on load / digest cycle\n           * return `0` if the DOM element is hidden\n           */\n          var onDigest = function() {\n            if ($scope.disabled === true) {\n              return unStickElement();\n            }\n            var offsetFromTop = elementsOffsetFromTop ($elem[0]);\n            if (offsetFromTop === 0) {\n              return offsetFromTop;\n            }\n            if (anchor === 'top') {\n              return (originalOffset || offsetFromTop) - elementsOffsetFromTop (scrollbar) + scrollbarYPos();\n            } else {\n              return offsetFromTop - scrollbarHeight() + $elem[0].offsetHeight + scrollbarYPos();\n            }\n          };\n\n          /**\n           * Triggered on change\n           */\n          var onChange = function (newVal, oldVal) {\n\n            /**\n             * Indicate if the DOM element is showed, or not\n             * @type {boolean}\n             */\n            var elemIsShowed = !!newVal;\n\n            /**\n             * Indicate if the DOM element was showed, or not\n             * @type {boolean}\n             */\n            var elemWasHidden = !oldVal;\n            var valChange = (newVal !== oldVal || typeof stickyLine === 'undefined');\n            var notSticking = (!isSticking && !isBottomedOut());\n\n            if (valChange && notSticking && newVal > 0 && elemIsShowed) {\n              stickyLine = newVal - offset;\n              //Update dimensions of sticky element when is showed\n              if (elemIsShowed && elemWasHidden) {\n                $scope.updateStickyContentUpdateDimensions($elem[0].offsetWidth, $elem[0].offsetHeight);\n              }\n              // IF the sticky is confined, we want to make sure the parent is relatively positioned,\n              // otherwise it won't bottom out properly\n              if (confine) {\n                $elem.parent().css({\n                  'position': 'relative'\n                });\n              }\n\n              // Get Parent height, so we know when to bottom out for confined stickies\n              var parent = $elem.parent()[0];\n\n              // Offset parent height by the elements height, if we're not using a placeholder\n              var parentHeight = parseInt (parent.offsetHeight) - (usePlaceholder ? 0 : $elem[0].offsetHeight);\n\n              // and now lets ensure we adhere to the bottom margins\n              // TODO: make this an attribute? Maybe like ignore-margin?\n              var marginBottom = parseInt ($elem.css('margin-bottom').replace(/px;?/, '')) || 0;\n\n              // specify the bottom out line for the sticky to unstick\n              var elementsDistanceFromTop = elementsOffsetFromTop ($elem[0]);\n              var parentsDistanceFromTop = elementsOffsetFromTop (parent)\n              var scrollbarDistanceFromTop = elementsOffsetFromTop (scrollbar);\n\n              var elementsDistanceFromScrollbarStart = elementsDistanceFromTop - scrollbarDistanceFromTop;\n              var elementsDistanceFromBottom = parentsDistanceFromTop + parentHeight - elementsDistanceFromTop;\n\n              stickyBottomLine = elementsDistanceFromScrollbarStart\n                + elementsDistanceFromBottom\n                - $elem[0].offsetHeight\n                - marginBottom\n                - offset\n                + +scrollbarYPos();\n\n              checkIfShouldStick();\n            }\n          };\n\n          /**\n           * Helper Functions\n           */\n\n          /**\n           * Create a placeholder\n           */\n          function createPlaceholder() {\n            if (usePlaceholder) {\n              // Remove the previous placeholder\n              if (placeholder) {\n                placeholder.remove();\n              }\n\n              placeholder = angular.element('<div>');\n              var elementsHeight = $elem[0].offsetHeight;\n              var computedStyle = $elem[0].currentStyle || window.getComputedStyle($elem[0]);\n              elementsHeight += parseInt(computedStyle.marginTop, 10);\n              elementsHeight += parseInt(computedStyle.marginBottom, 10);\n              elementsHeight += parseInt(computedStyle.borderTopWidth, 10);\n              elementsHeight += parseInt(computedStyle.borderBottomWidth, 10);\n              placeholder.css('height', $elem[0].offsetHeight + 'px');\n\n              $elem.after(placeholder);\n            }\n          }\n\n          /**\n           * Are we bottomed out of the parent element?\n           */\n          function isBottomedOut() {\n            if (confine && scrollbarYPos() > stickyBottomLine) {\n              return true;\n            }\n\n            return false;\n          }\n\n          /**\n           * Fetch top offset of element\n           */\n          function elementsOffsetFromTop(element) {\n            var offset = 0;\n\n            if (element.getBoundingClientRect) {\n              offset = element.getBoundingClientRect().top;\n            }\n\n            return offset;\n          }\n\n          /**\n           * Retrieves top scroll distance\n           */\n          function scrollbarYPos() {\n            var position;\n\n            if (typeof scrollbar.scrollTop !== 'undefined') {\n              position = scrollbar.scrollTop;\n            } else if (typeof scrollbar.pageYOffset !== 'undefined') {\n              position = scrollbar.pageYOffset;\n            } else {\n              position = document.documentElement.scrollTop;\n            }\n\n            return position;\n          }\n\n          /**\n           * Determine scrollbar's height\n           */\n          function scrollbarHeight() {\n            var height;\n\n            if (scrollbarElement[0] instanceof HTMLElement) {\n              // isn't bounding client rect cleaner than insane regex mess?\n              height = $window.getComputedStyle(scrollbarElement[0], null)\n                  .getPropertyValue('height')\n                  .replace(/px;?/, '');\n            } else {\n              height = $window.innerHeight;\n            }\n\n            return parseInt (height) || 0;\n          }\n\n          /**\n           * Checks if the media matches\n           */\n          function mediaQueryMatches() {\n            var mediaQuery = $attrs.mediaQuery || false;\n            var matchMedia = $window.matchMedia;\n\n            return mediaQuery && !(matchMedia ('(' + mediaQuery + ')').matches || matchMedia (mediaQuery).matches);\n          }\n\n          /**\n           * Get more accurate CSS values\n           */\n          function getCSS($el, prop){\n            var el = $el[0],\n                computed = window.getComputedStyle(el),\n                prevDisplay = computed.display,\n                val;\n\n            // hide the element so that we can get original css\n            // values instead of computed values\n            el.style.display = \"none\";\n\n            // NOTE - computed style declaration object is a reference\n            // to the element's CSSStyleDeclaration, so it will always\n            // reflect the current style of the element\n            val = computed[prop];\n\n            // restore previous display value\n            el.style.display = prevDisplay;\n\n            return val;\n          }\n\n          // public accessors for the controller to hitch into. Helps with external API access\n          $scope.getElement = function() { return $elem; };\n          $scope.getScrollbar = function() { return scrollbar; };\n          $scope.getInitialCSS = function() { return initialCSS; };\n          $scope.getAnchor = function() { return anchor; };\n          $scope.isSticking = function() { return isSticking; };\n          $scope.getOriginalInitialCSS = function() { return originalInitialCSS; };\n          // pass through aliases\n          $scope.processUnStickElement = function(anchor) { unStickElement(anchor)};\n          $scope.processCheckIfShouldStick =function() { checkIfShouldStick(); };\n\n          /**\n           * set the dimensions for the defaults of the content block occupied by the sticky element\n           */\n          $scope.getInitialDimensions = function() {\n            return {\n              zIndex: $elem.css('z-index'),\n              top: $elem.css('top'),\n              position: initialPosition, // revert to true initial state\n              marginTop: $elem.css('margin-top'),\n              marginBottom: $elem.css('margin-bottom'),\n              cssLeft: getCSS($elem, 'left'),\n              width: $elem[0].offsetWidth,\n              height: $elem.css('height')\n            };\n          };\n\n          /**\n           * only change content box dimensions\n           */\n          $scope.updateStickyContentUpdateDimensions = function(width, height) {\n            if (width && height) {\n              initSticky();\n              initialCSS.width = width + 'px';\n              initialCSS.height = height + 'px';\n            }\n          };\n\n          // ----------- configuration -----------\n\n          $timeout(function() {\n            originalInitialCSS = $scope.getInitialDimensions(); // preserve a copy\n            // Init the directive\n            initSticky();\n          },0);\n        },\n\n        /**\n         * +++++++++ public APIs+++++++++++++\n         */\n        controller: ['$scope', '$window', function($scope, $window) {\n\n          /**\n           * integration method allows for an outside client to reset the pinned state back to unpinned.\n           * Useful for when refreshing the scrollable DIV content completely\n           * if newWidth and newHeight integer values are not supplied then function will make a best guess\n           */\n          this.resetLayout = function(newWidth, newHeight) {\n\n            var scrollbar = $scope.getScrollbar(),\n                initialCSS = $scope.getInitialCSS(),\n                anchor = $scope.getAnchor();\n\n            function _resetScrollPosition() {\n\n              // reset means content is scrolled to anchor position\n              if (anchor === 'top') {\n                // window based scroller\n                if (scrollbar === $window) {\n                  $window.scrollTo(0, 0);\n                  // DIV based sticky scroller\n                } else {\n                  if (scrollbar.scrollTop > 0) {\n                    scrollbar.scrollTop = 0;\n                  }\n                }\n              }\n              // todo: need bottom use case\n            }\n\n            // only if pinned, force unpinning, otherwise height is inadvertently reset to 0\n            if ($scope.isSticking()) {\n              $scope.processUnStickElement (anchor);\n              $scope.processCheckIfShouldStick();\n            }\n            // remove layout-affecting attribures that were modified by this sticky\n            $scope.getElement().css({ 'width': '', 'height': '', 'position': '', 'top': '', zIndex: '' });\n            // model resets\n            initialCSS.position = $scope.getOriginalInitialCSS().position; // revert to original state\n            delete initialCSS.offsetWidth; // stickElement affected\n\n            // use this directive element's as default, if no measurements passed in\n            if (newWidth === undefined && newHeight === undefined) {\n              var e_bcr = $scope.getElement()[0].getBoundingClientRect();\n              newWidth = e_bcr.width;\n              newHeight = e_bcr.height;\n            }\n\n            // update model with new dimensions (if supplied from client's own measurement)\n            $scope.updateStickyContentUpdateDimensions(newWidth, newHeight); // update layout dimensions only\n\n            _resetScrollPosition();\n          };\n\n          /**\n           * return a reference to the scrolling element (window or DIV with overflow)\n           */\n          this.getScrollbar = function() {\n            return $scope.getScrollbar();\n          };\n        }]\n      };\n    }]\n );\n\n  // Shiv: matchMedia\n  window.matchMedia = window.matchMedia || (function() {\n      var warning = 'angular-sticky: This browser does not support ' +\n        'matchMedia, therefore the minWidth option will not work on ' +\n        'this browser. Polyfill matchMedia to fix this issue.';\n\n      if (window.console && console.warn) {\n        console.warn(warning);\n      }\n\n      return function() {\n        return {\n          matches: true\n        };\n      };\n    }());\n}());\n","//\n// Copyright Kamil Pkala http://github.com/kamilkp\n// Angular Virtual Scroll Repeat v1.1.7 2016/03/08\n//\n\n(function(window, angular) {\n    'use strict';\n    /* jshint eqnull:true */\n    /* jshint -W038 */\n\n    // DESCRIPTION:\n    // vsRepeat directive stands for Virtual Scroll Repeat. It turns a standard ngRepeated set of elements in a scrollable container\n    // into a component, where the user thinks he has all the elements rendered and all he needs to do is scroll (without any kind of\n    // pagination - which most users loath) and at the same time the browser isn't overloaded by that many elements/angular bindings etc.\n    // The directive renders only so many elements that can fit into current container's clientHeight/clientWidth.\n\n    // LIMITATIONS:\n    // - current version only supports an Array as a right-hand-side object for ngRepeat\n    // - all rendered elements must have the same height/width or the sizes of the elements must be known up front\n\n    // USAGE:\n    // In order to use the vsRepeat directive you need to place a vs-repeat attribute on a direct parent of an element with ng-repeat\n    // example:\n    // <div vs-repeat>\n    //      <div ng-repeat=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // or:\n    // <div vs-repeat>\n    //      <div ng-repeat-start=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    //      <div>\n    //         <!-- something in the middle -->\n    //      </div>\n    //      <div ng-repeat-end>\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // You can also measure the single element's height/width (including all paddings and margins), and then speficy it as a value\n    // of the attribute 'vs-repeat'. This can be used if one wants to override the automatically computed element size.\n    // example:\n    // <div vs-repeat=\"50\"> <!-- the specified element height is 50px -->\n    //      <div ng-repeat=\"item in someArray\">\n    //          <!-- content -->\n    //      </div>\n    // </div>\n    //\n    // IMPORTANT!\n    //\n    // - the vsRepeat directive must be applied to a direct parent of an element with ngRepeat\n    // - the value of vsRepeat attribute is the single element's height/width measured in pixels. If none provided, the directive\n    //      will compute it automatically\n\n    // OPTIONAL PARAMETERS (attributes):\n    // vs-repeat-container=\"selector\" - selector for element containing ng-repeat. (defaults to the current element)\n    // vs-scroll-parent=\"selector\" - selector to the scrollable container. The directive will look for a closest parent matching\n    //                              the given selector (defaults to the current element)\n    // vs-horizontal - stack repeated elements horizontally instead of vertically\n    // vs-offset-before=\"value\" - top/left offset in pixels (defaults to 0)\n    // vs-offset-after=\"value\" - bottom/right offset in pixels (defaults to 0)\n    // vs-excess=\"value\" - an integer number representing the number of elements to be rendered outside of the current container's viewport\n    //                      (defaults to 2)\n    // vs-size - a property name of the items in collection that is a number denoting the element size (in pixels)\n    // vs-autoresize - use this attribute without vs-size and without specifying element's size. The automatically computed element style will\n    //              readjust upon window resize if the size is dependable on the viewport size\n    // vs-scrolled-to-end=\"callback\" - callback will be called when the last item of the list is rendered\n    // vs-scrolled-to-end-offset=\"integer\" - set this number to trigger the scrolledToEnd callback n items before the last gets rendered\n    // vs-scrolled-to-beginning=\"callback\" - callback will be called when the first item of the list is rendered\n    // vs-scrolled-to-beginning-offset=\"integer\" - set this number to trigger the scrolledToBeginning callback n items before the first gets rendered\n\n    // EVENTS:\n    // - 'vsRepeatTrigger' - an event the directive listens for to manually trigger reinitialization\n    // - 'vsRepeatReinitialized' - an event the directive emits upon reinitialization done\n\n    var dde = document.documentElement,\n        matchingFunction = dde.matches ? 'matches' :\n                            dde.matchesSelector ? 'matchesSelector' :\n                            dde.webkitMatches ? 'webkitMatches' :\n                            dde.webkitMatchesSelector ? 'webkitMatchesSelector' :\n                            dde.msMatches ? 'msMatches' :\n                            dde.msMatchesSelector ? 'msMatchesSelector' :\n                            dde.mozMatches ? 'mozMatches' :\n                            dde.mozMatchesSelector ? 'mozMatchesSelector' : null;\n\n    var closestElement = angular.element.prototype.closest || function (selector) {\n        var el = this[0].parentNode;\n        while (el !== document.documentElement && el != null && !el[matchingFunction](selector)) {\n            el = el.parentNode;\n        }\n\n        if (el && el[matchingFunction](selector)) {\n            return angular.element(el);\n        }\n        else {\n            return angular.element();\n        }\n    };\n\n    function getWindowScroll() {\n        if ('pageYOffset' in window) {\n            return {\n                scrollTop: pageYOffset,\n                scrollLeft: pageXOffset\n            };\n        }\n        else {\n            var sx, sy, d = document, r = d.documentElement, b = d.body;\n            sx = r.scrollLeft || b.scrollLeft || 0;\n            sy = r.scrollTop || b.scrollTop || 0;\n            return {\n                scrollTop: sy,\n                scrollLeft: sx\n            };\n        }\n    }\n\n    function getClientSize(element, sizeProp) {\n        if (element === window) {\n            return sizeProp === 'clientWidth' ? window.innerWidth : window.innerHeight;\n        }\n        else {\n            return element[sizeProp];\n        }\n    }\n\n    function getScrollPos(element, scrollProp) {\n        return element === window ? getWindowScroll()[scrollProp] : element[scrollProp];\n    }\n\n    function getScrollOffset(vsElement, scrollElement, isHorizontal) {\n        var vsPos = vsElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n        var scrollPos = scrollElement === window ? 0 : scrollElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];\n        var correction = vsPos - scrollPos +\n            (scrollElement === window ? getWindowScroll() : scrollElement)[isHorizontal ? 'scrollLeft' : 'scrollTop'];\n\n        return correction;\n    }\n\n    var vsRepeatModule = angular.module('vs-repeat', []).directive('vsRepeat', ['$compile', '$parse', function($compile, $parse) {\n        return {\n            restrict: 'A',\n            scope: true,\n            compile: function($element, $attrs) {\n                var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,\n                    ngRepeatChild = repeatContainer.children().eq(0),\n                    ngRepeatExpression,\n                    childCloneHtml = ngRepeatChild[0].outerHTML,\n                    expressionMatches,\n                    lhs,\n                    rhs,\n                    rhsSuffix,\n                    originalNgRepeatAttr,\n                    collectionName = '$vs_collection',\n                    isNgRepeatStart = false,\n                    attributesDictionary = {\n                        'vsRepeat': 'elementSize',\n                        'vsOffsetBefore': 'offsetBefore',\n                        'vsOffsetAfter': 'offsetAfter',\n                        'vsScrolledToEndOffset': 'scrolledToEndOffset',\n                        'vsScrolledToBeginningOffset': 'scrolledToBeginningOffset',\n                        'vsExcess': 'excess'\n                    };\n\n                if (ngRepeatChild.attr('ng-repeat')) {\n                    originalNgRepeatAttr = 'ng-repeat';\n                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat');\n                }\n                else if (ngRepeatChild.attr('data-ng-repeat')) {\n                    originalNgRepeatAttr = 'data-ng-repeat';\n                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat');\n                }\n                else if (ngRepeatChild.attr('ng-repeat-start')) {\n                    isNgRepeatStart = true;\n                    originalNgRepeatAttr = 'ng-repeat-start';\n                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat-start');\n                }\n                else if (ngRepeatChild.attr('data-ng-repeat-start')) {\n                    isNgRepeatStart = true;\n                    originalNgRepeatAttr = 'data-ng-repeat-start';\n                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat-start');\n                }\n                else {\n                    throw new Error('angular-vs-repeat: no ng-repeat directive on a child element');\n                }\n\n                expressionMatches = /^\\s*(\\S+)\\s+in\\s+([\\S\\s]+?)(track\\s+by\\s+\\S+)?$/.exec(ngRepeatExpression);\n                lhs = expressionMatches[1];\n                rhs = expressionMatches[2];\n                rhsSuffix = expressionMatches[3];\n\n                if (isNgRepeatStart) {\n                    var index = 0;\n                    var repeaterElement = repeatContainer.children().eq(0);\n                    while(repeaterElement.attr('ng-repeat-end') == null && repeaterElement.attr('data-ng-repeat-end') == null) {\n                        index++;\n                        repeaterElement = repeatContainer.children().eq(index);\n                        childCloneHtml += repeaterElement[0].outerHTML;\n                    }\n                }\n\n                repeatContainer.empty();\n                return {\n                    pre: function($scope, $element, $attrs) {\n                        var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,\n                            childClone = angular.element(childCloneHtml),\n                            childTagName = childClone[0].tagName.toLowerCase(),\n                            originalCollection = [],\n                            originalLength,\n                            $$horizontal = typeof $attrs.vsHorizontal !== 'undefined',\n                            $beforeContent = angular.element('<' + childTagName + ' class=\"vs-repeat-before-content\"></' + childTagName + '>'),\n                            $afterContent = angular.element('<' + childTagName + ' class=\"vs-repeat-after-content\"></' + childTagName + '>'),\n                            autoSize = !$attrs.vsRepeat,\n                            sizesPropertyExists = !!$attrs.vsSize || !!$attrs.vsSizeProperty,\n                            $scrollParent = $attrs.vsScrollParent ?\n                                $attrs.vsScrollParent === 'window' ? angular.element(window) :\n                                closestElement.call(repeatContainer, $attrs.vsScrollParent) : repeatContainer,\n                            $$options = 'vsOptions' in $attrs ? $scope.$eval($attrs.vsOptions) : {},\n                            clientSize = $$horizontal ? 'clientWidth' : 'clientHeight',\n                            offsetSize = $$horizontal ? 'offsetWidth' : 'offsetHeight',\n                            scrollPos = $$horizontal ? 'scrollLeft' : 'scrollTop';\n\n                        $scope.totalSize = 0;\n                        if (!('vsSize' in $attrs) && 'vsSizeProperty' in $attrs) {\n                            console.warn('vs-size-property attribute is deprecated. Please use vs-size attribute which also accepts angular expressions.');\n                        }\n\n                        if ($scrollParent.length === 0) {\n                            throw 'Specified scroll parent selector did not match any element';\n                        }\n                        $scope.$scrollParent = $scrollParent;\n\n                        if (sizesPropertyExists) {\n                            $scope.sizesCumulative = [];\n                        }\n\n                        //initial defaults\n                        $scope.elementSize = (+$attrs.vsRepeat) || getClientSize($scrollParent[0], clientSize) || 50;\n                        $scope.offsetBefore = 0;\n                        $scope.offsetAfter = 0;\n                        $scope.excess = 2;\n\n                        if ($$horizontal) {\n                            $beforeContent.css('height', '100%');\n                            $afterContent.css('height', '100%');\n                        }\n                        else {\n                            $beforeContent.css('width', '100%');\n                            $afterContent.css('width', '100%');\n                        }\n\n                        Object.keys(attributesDictionary).forEach(function(key) {\n                            if ($attrs[key]) {\n                                $attrs.$observe(key, function(value) {\n                                    // '+' serves for getting a number from the string as the attributes are always strings\n                                    $scope[attributesDictionary[key]] = +value;\n                                    reinitialize();\n                                });\n                            }\n                        });\n\n\n                        $scope.$watchCollection(rhs, function(coll) {\n                            originalCollection = coll || [];\n                            refresh();\n                        });\n\n                        function refresh() {\n                            if (!originalCollection || originalCollection.length < 1) {\n                                $scope[collectionName] = [];\n                                originalLength = 0;\n                                $scope.sizesCumulative = [0];\n                            }\n                            else {\n                                originalLength = originalCollection.length;\n                                if (sizesPropertyExists) {\n                                    $scope.sizes = originalCollection.map(function(item) {\n                                        var s = $scope.$new(false);\n                                        angular.extend(s, item);\n                                        s[lhs] = item;\n                                        var size = ($attrs.vsSize || $attrs.vsSizeProperty) ?\n                                                        s.$eval($attrs.vsSize || $attrs.vsSizeProperty) :\n                                                        $scope.elementSize;\n                                        s.$destroy();\n                                        return size;\n                                    });\n                                    var sum = 0;\n                                    $scope.sizesCumulative = $scope.sizes.map(function(size) {\n                                        var res = sum;\n                                        sum += size;\n                                        return res;\n                                    });\n                                    $scope.sizesCumulative.push(sum);\n                                }\n                                else {\n                                    setAutoSize();\n                                }\n                            }\n\n                            reinitialize();\n                        }\n\n                        function setAutoSize() {\n                            if (autoSize) {\n                                $scope.$$postDigest(function() {\n                                    if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) { // element is visible\n                                        var children = repeatContainer.children(),\n                                            i = 0,\n                                            gotSomething = false,\n                                            insideStartEndSequence = false;\n\n                                        while (i < children.length) {\n                                            if (children[i].attributes[originalNgRepeatAttr] != null || insideStartEndSequence) {\n                                                if (!gotSomething) {\n                                                    $scope.elementSize = 0;\n                                                }\n\n                                                gotSomething = true;\n                                                if (children[i][offsetSize]) {\n                                                    $scope.elementSize += children[i][offsetSize];\n                                                }\n\n                                                if (isNgRepeatStart) {\n                                                    if (children[i].attributes['ng-repeat-end'] != null || children[i].attributes['data-ng-repeat-end'] != null) {\n                                                        break;\n                                                    }\n                                                    else {\n                                                        insideStartEndSequence = true;\n                                                    }\n                                                }\n                                                else {\n                                                    break;\n                                                }\n                                            }\n                                            i++;\n                                        }\n\n                                        if (gotSomething) {\n                                            reinitialize();\n                                            autoSize = false;\n                                            if ($scope.$root && !$scope.$root.$$phase) {\n                                                $scope.$apply();\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        var dereg = $scope.$watch(function() {\n                                            if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) {\n                                                dereg();\n                                                setAutoSize();\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        }\n\n                        function getLayoutProp() {\n                            var layoutPropPrefix = childTagName === 'tr' ? '' : 'min-';\n                            var layoutProp = $$horizontal ? layoutPropPrefix + 'width' : layoutPropPrefix + 'height';\n                            return layoutProp;\n                        }\n\n                        childClone.eq(0).attr(originalNgRepeatAttr, lhs + ' in ' + collectionName + (rhsSuffix ? ' ' + rhsSuffix : ''));\n                        childClone.addClass('vs-repeat-repeated-element');\n\n                        repeatContainer.append($beforeContent);\n                        repeatContainer.append(childClone);\n                        $compile(childClone)($scope);\n                        repeatContainer.append($afterContent);\n\n                        $scope.startIndex = 0;\n                        $scope.endIndex = 0;\n\n                        function scrollHandler() {\n                            if (updateInnerCollection()) {\n                                $scope.$digest();\n                            }\n                        }\n\n                        $scrollParent.on('scroll', scrollHandler);\n\n                        function onWindowResize() {\n                            if (typeof $attrs.vsAutoresize !== 'undefined') {\n                                autoSize = true;\n                                setAutoSize();\n                                if ($scope.$root && !$scope.$root.$$phase) {\n                                    $scope.$apply();\n                                }\n                            }\n                            if (updateInnerCollection()) {\n                                $scope.$apply();\n                            }\n                        }\n\n                        angular.element(window).on('resize', onWindowResize);\n                        $scope.$on('$destroy', function() {\n                            angular.element(window).off('resize', onWindowResize);\n                            $scrollParent.off('scroll', scrollHandler);\n                        });\n\n                        $scope.$on('vsRepeatTrigger', refresh);\n\n                        $scope.$on('vsRepeatResize', function() {\n                            autoSize = true;\n                            setAutoSize();\n                        });\n\n                        var _prevStartIndex,\n                            _prevEndIndex,\n                            _minStartIndex,\n                            _maxEndIndex;\n\n                        $scope.$on('vsRenderAll', function() {//e , quantum) {\n                            if($$options.latch) {\n                                setTimeout(function() {\n                                    // var __endIndex = Math.min($scope.endIndex + (quantum || 1), originalLength);\n                                    var __endIndex = originalLength;\n                                    _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n                                    $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;\n                                    $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);\n                                    _prevEndIndex = $scope.endIndex;\n\n                                    $scope.$$postDigest(function() {\n                                        $beforeContent.css(getLayoutProp(), 0);\n                                        $afterContent.css(getLayoutProp(), 0);\n                                    });\n\n                                    $scope.$apply(function() {\n                                        $scope.$emit('vsRenderAllDone');\n                                    });\n                                });\n                            }\n                        });\n\n                        function reinitialize() {\n                            _prevStartIndex = void 0;\n                            _prevEndIndex = void 0;\n                            _minStartIndex = originalLength;\n                            _maxEndIndex = 0;\n                            updateTotalSize(sizesPropertyExists ?\n                                                $scope.sizesCumulative[originalLength] :\n                                                $scope.elementSize * originalLength\n                                            );\n                            updateInnerCollection();\n\n                            $scope.$emit('vsRepeatReinitialized', $scope.startIndex, $scope.endIndex);\n                        }\n\n                        function updateTotalSize(size) {\n                            $scope.totalSize = $scope.offsetBefore + size + $scope.offsetAfter;\n                        }\n\n                        var _prevClientSize;\n                        function reinitOnClientHeightChange() {\n                            var ch = getClientSize($scrollParent[0], clientSize);\n                            if (ch !== _prevClientSize) {\n                                reinitialize();\n                                if ($scope.$root && !$scope.$root.$$phase) {\n                                    $scope.$apply();\n                                }\n                            }\n                            _prevClientSize = ch;\n                        }\n\n                        $scope.$watch(function() {\n                            if (typeof window.requestAnimationFrame === 'function') {\n                                window.requestAnimationFrame(reinitOnClientHeightChange);\n                            }\n                            else {\n                                reinitOnClientHeightChange();\n                            }\n                        });\n\n                        function updateInnerCollection() {\n                            var $scrollPosition = getScrollPos($scrollParent[0], scrollPos);\n                            var $clientSize = getClientSize($scrollParent[0], clientSize);\n\n                            var scrollOffset = repeatContainer[0] === $scrollParent[0] ? 0 : getScrollOffset(\n                                                    repeatContainer[0],\n                                                    $scrollParent[0],\n                                                    $$horizontal\n                                                );\n\n                            var __startIndex = $scope.startIndex;\n                            var __endIndex = $scope.endIndex;\n\n                            if (sizesPropertyExists) {\n                                __startIndex = 0;\n                                while ($scope.sizesCumulative[__startIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset) {\n                                    __startIndex++;\n                                }\n                                if (__startIndex > 0) { __startIndex--; }\n\n                                // Adjust the start index according to the excess\n                                __startIndex = Math.max(\n                                    Math.floor(__startIndex - $scope.excess / 2),\n                                    0\n                                );\n\n                                __endIndex = __startIndex;\n                                while ($scope.sizesCumulative[__endIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset + $clientSize) {\n                                    __endIndex++;\n                                }\n\n                                // Adjust the end index according to the excess\n                                __endIndex = Math.min(\n                                    Math.ceil(__endIndex + $scope.excess / 2),\n                                    originalLength\n                                );\n                            }\n                            else {\n                                __startIndex = Math.max(\n                                    Math.floor(\n                                        ($scrollPosition - $scope.offsetBefore - scrollOffset) / $scope.elementSize\n                                    ) - $scope.excess / 2,\n                                    0\n                                );\n\n                                __endIndex = Math.min(\n                                    __startIndex + Math.ceil(\n                                        $clientSize / $scope.elementSize\n                                    ) + $scope.excess,\n                                    originalLength\n                                );\n                            }\n\n                            _minStartIndex = Math.min(__startIndex, _minStartIndex);\n                            _maxEndIndex = Math.max(__endIndex, _maxEndIndex);\n\n                            $scope.startIndex = $$options.latch ? _minStartIndex : __startIndex;\n                            $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;\n\n                            var digestRequired = false;\n                            if (_prevStartIndex == null) {\n                                digestRequired = true;\n                            }\n                            else if (_prevEndIndex == null) {\n                                digestRequired = true;\n                            }\n\n                            if (!digestRequired) {\n                                if ($$options.hunked) {\n                                    if (Math.abs($scope.startIndex - _prevStartIndex) >= $scope.excess / 2 ||\n                                        ($scope.startIndex === 0 && _prevStartIndex !== 0)) {\n                                        digestRequired = true;\n                                    }\n                                    else if (Math.abs($scope.endIndex - _prevEndIndex) >= $scope.excess / 2 ||\n                                        ($scope.endIndex === originalLength && _prevEndIndex !== originalLength)) {\n                                        digestRequired = true;\n                                    }\n                                }\n                                else {\n                                    digestRequired = $scope.startIndex !== _prevStartIndex ||\n                                                        $scope.endIndex !== _prevEndIndex;\n                                }\n                            }\n\n                            if (digestRequired) {\n                                $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);\n\n                                // Emit the event\n                                $scope.$emit('vsRepeatInnerCollectionUpdated', $scope.startIndex, $scope.endIndex, _prevStartIndex, _prevEndIndex);\n                                var triggerIndex;\n                                if ($attrs.vsScrolledToEnd) {\n                                    triggerIndex = originalCollection.length - ($scope.scrolledToEndOffset || 0);\n                                    if (($scope.endIndex >= triggerIndex && _prevEndIndex < triggerIndex) || (originalCollection.length && $scope.endIndex === originalCollection.length)) {\n                                        $scope.$eval($attrs.vsScrolledToEnd);\n                                    }\n                                }\n                                if ($attrs.vsScrolledToBeginning) {\n                                    triggerIndex = $scope.scrolledToBeginningOffset || 0;\n                                    if (($scope.startIndex <= triggerIndex && _prevStartIndex > $scope.startIndex)) {\n                                        $scope.$eval($attrs.vsScrolledToBeginning);\n                                    }\n                                }\n\n                                _prevStartIndex = $scope.startIndex;\n                                _prevEndIndex = $scope.endIndex;\n\n                                var offsetCalculationString = sizesPropertyExists ?\n                                    '(sizesCumulative[$index + startIndex] + offsetBefore)' :\n                                    '(($index + startIndex) * elementSize + offsetBefore)';\n\n                                var parsed = $parse(offsetCalculationString);\n                                var o1 = parsed($scope, {$index: 0});\n                                var o2 = parsed($scope, {$index: $scope[collectionName].length});\n                                var total = $scope.totalSize;\n\n                                $beforeContent.css(getLayoutProp(), o1 + 'px');\n                                $afterContent.css(getLayoutProp(), (total - o2) + 'px');\n                            }\n\n                            return digestRequired;\n                        }\n                    }\n                };\n            }\n        };\n    }]);\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = vsRepeatModule.name;\n    }\n})(window, window.angular);\n"],"sourceRoot":""}