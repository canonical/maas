# Generated by Django 2.2.12 on 2022-03-08 16:06

from django.db import migrations, models
from django.db.models import F, Min, Prefetch
from django.db.models.fields.json import KeyTextTransform
from django.db.models.functions import Coalesce

DEFAULT_BIOS_BOOT_METHOD = "pxe"
KNOWN_BIOS_BOOT_METHODS = frozenset(
    ("pxe", "uefi", "powernv", "powerkvm", "s390x_partition")
)
MIB = 1024**2
MIN_BOOT_PARTITION_SIZE = 512 * MIB

VMFS6_PARTITIONS_SIZE = (
    3 * MIB,
    4096 * MIB,
    None,  # datastore has variable size
    249 * MIB,
    249 * MIB,
    109 * MIB,
    285 * MIB,
    2560 * MIB,
)
VMFS7_PARTITIONS_SIZE = (
    105 * MIB,
    1074 * MIB,
    1074 * MIB,
    8704 * MIB,
    None,
)
VMFS6_INDEXES = (1, 2, 3, 5, 6, 7, 8, 9)
VMFS7_INDEXES = (1, 5, 6, 7, 8)


def populate_partition_index(apps, schema_editor):
    PartitionTable = apps.get_model("maasserver", "PartitionTable")
    Node = apps.get_model("maasserver", "Node")
    Partition = apps.get_model("maasserver", "Partition")
    node_boot_disks = get_node_boot_disks(Node)
    boot_disks = set(node_boot_disks.values())
    nodes = get_nodes(Node, node_boot_disks)
    partition_tables = (
        PartitionTable.objects.prefetch_related(
            Prefetch("partitions", queryset=Partition.objects.order_by("id"))
        )
        .annotate(
            node_id=F("block_device__node_config__node_id"),
            physicalblockdevice_id=F("block_device__physicalblockdevice__id"),
        )
        .all()
    )
    for ptable in partition_tables:
        partitions = list(ptable.partitions.all())
        indexes = list(range(1, len(partitions) + 1))
        node = nodes[ptable.node_id]
        need_prep_partition = (
            node.arch == "ppc64el" and ptable.block_device_id in boot_disks
        )
        need_bios_grub = (
            node.arch == "amd64"
            and node.bios_boot_method != "uefi"
            # consider only physical disks
            and ptable.physicalblockdevice_id is not None
        )
        if ptable.table_type == "MBR":
            # the 4th partition and onwards are extended
            indexes = indexes[:3] + [i + 1 for i in indexes[4:]]
        elif ptable.table_type == "GPT":
            part_sizes = [part.size for part in partitions]
            if partitions_size_match(part_sizes, VMFS6_PARTITIONS_SIZE):
                indexes = VMFS6_INDEXES
            elif partitions_size_match(part_sizes, VMFS7_PARTITIONS_SIZE):
                indexes = VMFS7_INDEXES
            elif need_prep_partition or need_bios_grub:
                indexes = [i + 1 for i in indexes]
        for index, partition in zip(indexes, partitions):
            partition.index = index
            partition.save()


def get_node_boot_disks(Node):
    """Map node IDs to its boot disk ID."""
    return dict(
        Node.objects.filter(
            current_config__blockdevice__physicalblockdevice__id__isnull=False,
            current_config__blockdevice__size__gte=MIN_BOOT_PARTITION_SIZE,
        )
        .annotate(
            disk_id=Coalesce(
                "boot_disk_id",
                Min("current_config__blockdevice__physicalblockdevice__id"),
                output_field=models.IntegerField(),
            )
        )
        .values_list("id", "disk_id")
    )


def get_nodes(Node, node_boot_disks):
    """Map node IDs to nodes."""
    nodes = Node.objects.annotate(
        bmc_power_type=F("bmc__power_type"),
        bmc_power_boot_type=KeyTextTransform(
            "power_boot_type", f"bmc__power_parameters"
        ),
    ).all()
    return {
        node.id: annotate_node(node, node_boot_disks.get(node.id))
        for node in nodes
    }


def annotate_node(node, node_boot_disk_id):
    node.arch = node.architecture.split("/", 1)[0] if node.architecture else ""
    node.bios_boot_method = get_bios_boot_method(node)
    node.boot_disk_id = node_boot_disk_id
    return node


def get_bios_boot_method(node):
    # logic here is copied from from Node.get_bios_boot_method()
    if node.bios_boot_method:
        if node.bios_boot_method in KNOWN_BIOS_BOOT_METHODS:
            return node.bios_boot_method
        return DEFAULT_BIOS_BOOT_METHOD
    if node.bmc_power_type == "ipmi" and node.bmc_power_boot_type == "efi":
        return "uefi"
    return DEFAULT_BIOS_BOOT_METHOD


def partitions_size_match(actual_sizes, expected_sizes):
    if len(actual_sizes) != len(expected_sizes):
        return
    return all(
        expected_size in (None, actual_size)
        for expected_size, actual_size in zip(actual_sizes, expected_sizes)
    )


class Migration(migrations.Migration):
    dependencies = [
        ("maasserver", "0267_add_machine_specific_sync_interval_fields"),
    ]

    operations = [
        migrations.AddField(
            model_name="partition",
            name="index",
            field=models.IntegerField(default=0),
            preserve_default=False,
        ),
        migrations.RunPython(populate_partition_index),
        migrations.AlterUniqueTogether(
            name="partition",
            unique_together={("partition_table", "index")},
        ),
    ]
